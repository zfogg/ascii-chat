{"id":"as-0z4","title":"Refine crypto module documentation - accuracy and tone","description":"Review docs/topics/crypto.dox, module_crypto_organization.dox, and lib/crypto/README.md. Verify Ed25519/X25519 usage claims against actual code. Clarify signing vs key exchange. Remove AI buzzwords. Cross-reference lib/crypto/*.c files for accuracy. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:41:56Z","created_by":"mayor","updated_at":"2026-02-24T01:41:56Z"}
{"id":"as-4yo","title":"Refine socket and network documentation","description":"Review docs/topics/socket.dox and network.dox. Simplify network layer descriptions. Add practical TCP/WebSocket examples from lib/network/ code. Verify socket API descriptions. Replace AI-formal tone with natural language. Check socket buffering and polling explanations. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:11Z","created_by":"mayor","updated_at":"2026-02-24T01:42:11Z"}
{"id":"as-572","title":"Refine FFmpeg and media handling documentation","description":"Review include/ascii-chat/media/ffmpeg_encoder.dox. Simplify encoder descriptions. Verify codec names and options. Cross-reference lib/media/ implementation. Add practical encoding examples. Replace technical jargon. Humanize tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:41Z","created_by":"mayor","updated_at":"2026-02-24T01:42:41Z"}
{"id":"as-5sw","title":"Refine testing and quality assurance documentation","description":"Review docs/topics/testing.dox. Simplify test framework descriptions. Add example test cases. Verify test tool usage matches actual test implementations. Cross-reference tests/ directory. Remove formal AI tone. Add practical testing examples. Do NOT build or run tests, only review and refine docs.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:39Z","created_by":"mayor","updated_at":"2026-02-24T01:42:39Z"}
{"id":"as-5x9","title":"Refine handshake and key exchange documentation","description":"Review docs/topics/handshake.dox. Simplify key exchange descriptions. Verify TLS/SSH key handling. Cross-reference lib/crypto/handshake.c. Add protocol flow diagrams or step examples. Remove overly technical jargon. Humanize tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:27Z","created_by":"mayor","updated_at":"2026-02-24T01:42:27Z"}
{"id":"as-aaf","title":"Refine error handling and exit codes documentation","description":"Review docs/topics/exit_codes.dox, errno.dox. Simplify error descriptions. Add practical examples of error scenarios. Verify error code values match actual code. Cross-reference lib/errno/ and error handling. Remove overly formal phrasing. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:43Z","created_by":"mayor","updated_at":"2026-02-24T01:42:43Z"}
{"id":"as-af8","title":"Refine packet and protocol documentation","description":"Review docs/topics/packet_types.dox, packet_queue.dox. Simplify packet structure descriptions. Add packet flow examples. Verify packet type descriptions match protocol.h files. Cross-reference actual packet handling code. Humanize tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:29Z","created_by":"mayor","updated_at":"2026-02-24T01:42:29Z"}
{"id":"as-awr","title":"Refine audio module documentation - clarity and examples","description":"Review docs/topics/audio.dox, client_audio.dox, and mixer documentation. Simplify complex audio pipeline descriptions. Add concrete examples. Cross-reference lib/audio/*.c for accuracy. Tone down AI-ish phrasing. Ensure PCM, mixing, and playback flow is clear. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:05Z","created_by":"mayor","updated_at":"2026-02-24T01:42:05Z"}
{"id":"as-ays","title":"Refine session module documentation - humanize tone and examples","description":"Review src/common/session/README.md and session.dox. Rewrite sections to sound natural, not AI-generated. Verify keyboard input documentation against keyboard_handler.c. Check color filter and display mode descriptions. Add practical examples of session lifecycle. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:41:51Z","created_by":"mayor","updated_at":"2026-02-24T01:41:51Z"}
{"id":"as-bhd","title":"Refine ACDS and service discovery documentation","description":"Review docs/topics/acds.dox. Simplify service discovery and peer discovery sections. Verify TCP/UDP port descriptions. Add practical ACDS usage examples. Cross-reference deploy/acds/ implementation. Humanize tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:20Z","created_by":"mayor","updated_at":"2026-02-24T01:42:20Z"}
{"id":"as-bid","title":"Refine compression and data format documentation","description":"Review docs/topics/compression.dox. Simplify codec and compression descriptions. Verify lz4/zstd claims match actual usage. Cross-reference lib/compression/ code. Add practical examples. Replace AI-formal tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:28Z","created_by":"mayor","updated_at":"2026-02-24T01:42:28Z"}
{"id":"as-bx4","title":"Refine logging and debug documentation","description":"Review include/ascii-chat/log/logging.dox and docs/topics/debug.dox, lock_debug.dox. Simplify technical jargon. Add real usage examples from codebase. Verify debug tool descriptions match actual implementation. Remove overly formal tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:03Z","created_by":"mayor","updated_at":"2026-02-24T01:42:03Z"}
{"id":"as-fmr","title":"Refine terminal and system integration documentation","description":"Review docs/topics/keys.dox and terminal-related sections. Simplify VT escape code descriptions. Verify key event handling against keyboard_handler.c. Add examples of key sequences. Cross-reference actual terminal interactions. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:42Z","created_by":"mayor","updated_at":"2026-02-24T01:42:42Z"}
{"id":"as-g56","title":"Refine utility and helper modules documentation","description":"Review docs/topics/util.dox, buffer_pool.dox, packet_queue.dox, ringbuffer.dox, errno.dox. Simplify data structure descriptions. Verify implementation details match lib/util/ code. Add usage examples. Remove AI-formal phrasing. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:21Z","created_by":"mayor","updated_at":"2026-02-24T01:42:21Z"}
{"id":"as-hbp","title":"Refine options and config system documentation","description":"Review docs/topics/options.dox, config.dox, and include/ascii-chat/options/architecture.dox. Simplify option builder patterns. Add registry examples. Verify option preset descriptions match lib/options/presets.c. Humanize tone. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:12Z","created_by":"mayor","updated_at":"2026-02-24T01:42:12Z"}
{"id":"as-kqd","title":"Refine platform module documentation - verify threading and filesystem APIs","description":"Review docs/topics/platform.dox. Verify all threading API functions exist (platform_thread_create, platform_mutex_*, etc). Check filesystem API accuracy. Humanize tone - remove AI formality. Cross-reference lib/platform/posix/ and lib/platform/windows/ implementations. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:02Z","created_by":"mayor","updated_at":"2026-02-24T01:42:02Z"}
{"id":"as-m0l","title":"Refine server module documentation","description":"Review docs/topics/server.dox, server_*.dox files. Humanize formal tone. Verify server state machine accuracy. Check render, stream, and protocol descriptions match actual code. Add practical examples. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:13Z","created_by":"mayor","updated_at":"2026-02-24T01:42:13Z"}
{"id":"as-vty","title":"Refine build system and dependencies documentation","description":"Review docs/topics/build.dox, dependencies.dox. Simplify CMake and build descriptions. Verify dependency version requirements. Cross-reference CMakeLists.txt. Add practical build command examples. Replace technical jargon with clear steps. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:31Z","created_by":"mayor","updated_at":"2026-02-24T01:42:31Z"}
{"id":"as-wisp-046","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-046","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-046","depends_on_id":"as-wisp-ull","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-05d","title":"Process witness mail","description":"First, clean up any stale patrol wisps from abnormal exits in previous cycles:\n```bash\nbd mol wisp gc --age 1h\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-05d","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-1ba","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-1ba","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-1ba","depends_on_id":"as-wisp-tfu","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-1dj","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-2cp","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-2cp","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-2cp","depends_on_id":"as-wisp-9g1","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-2cv","title":"Process witness mail","description":"First, clean up any stale patrol wisps from abnormal exits in previous cycles:\n```bash\nbd mol wisp gc --age 1h\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-2cv","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-2j9","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-2j9","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-2j9","depends_on_id":"as-wisp-bd7","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-33a","title":"Inspect all active polecats","description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ntmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log origin/main..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `tmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-33a","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-33a","depends_on_id":"as-wisp-yau","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-3nu","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-3nu","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-3nu","depends_on_id":"as-wisp-a3b","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-4g6","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-4g6","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-4g6","depends_on_id":"as-wisp-wnk","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-4hv","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-4p5","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-4p5","depends_on_id":"as-wisp-5jr","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-4p5","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-5jr","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-5jr","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-5jr","depends_on_id":"as-wisp-s5b","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-5lg","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and assess queue health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 2a: Track queue non-empty duration**\n\nUse your agent bead labels to track when the MR queue first became non-empty.\nThis persists across patrol cycles and survives session restarts.\n\nResolve your agent bead ID (same as in loop-or-exit step).\n\nRead current state:\n```bash\ngt agent state YOUR_AGENT_BEAD --json\n```\nLook for the `mr_queue_nonempty_since` label.\n\n**If the queue has open MRs:**\n- If `mr_queue_nonempty_since` is NOT set: record the current time.\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --set mr_queue_nonempty_since=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n  ```\n- If `mr_queue_nonempty_since` IS set: calculate how long the queue has been\n  non-empty. Factor this duration into your staleness assessment â€” a queue that\n  has been non-empty for an extended period with no progress is more concerning\n  than one that just became non-empty.\n\n**If the queue is empty (no open MRs):**\n- Clear the timestamp:\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --del mr_queue_nonempty_since\n  ```\n\n**Step 3: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nQueue non-empty since: \u003cmr_queue_nonempty_since or N/A\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-5lg","depends_on_id":"as-wisp-chj","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-5lg","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-6km","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-6km","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-6km","depends_on_id":"as-wisp-ugb","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-6mi","title":"Process witness mail","description":"First, clean up any stale patrol wisps from abnormal exits in previous cycles:\n```bash\nbd mol wisp gc --age 1h\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-6mi","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-6q9","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-71v","title":"Inspect all active polecats","description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ntmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log origin/main..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `tmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-71v","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-71v","depends_on_id":"as-wisp-80m","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-80m","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and assess queue health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 2a: Track queue non-empty duration**\n\nUse your agent bead labels to track when the MR queue first became non-empty.\nThis persists across patrol cycles and survives session restarts.\n\nResolve your agent bead ID (same as in loop-or-exit step).\n\nRead current state:\n```bash\ngt agent state YOUR_AGENT_BEAD --json\n```\nLook for the `mr_queue_nonempty_since` label.\n\n**If the queue has open MRs:**\n- If `mr_queue_nonempty_since` is NOT set: record the current time.\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --set mr_queue_nonempty_since=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n  ```\n- If `mr_queue_nonempty_since` IS set: calculate how long the queue has been\n  non-empty. Factor this duration into your staleness assessment â€” a queue that\n  has been non-empty for an extended period with no progress is more concerning\n  than one that just became non-empty.\n\n**If the queue is empty (no open MRs):**\n- Clear the timestamp:\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --del mr_queue_nonempty_since\n  ```\n\n**Step 3: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nQueue non-empty since: \u003cmr_queue_nonempty_since or N/A\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-80m","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-80m","depends_on_id":"as-wisp-92n","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-81i","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-81i","depends_on_id":"as-wisp-33a","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-81i","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-89f","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-89f","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-89f","depends_on_id":"as-wisp-xa1","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-8i7","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-8i7","depends_on_id":"as-wisp-4p5","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-8i7","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-8ii","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-8ii","depends_on_id":"as-wisp-8i7","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-8ii","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-92n","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-92n","depends_on_id":"as-wisp-05d","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-92n","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-9ff","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-9g1","title":"Inspect all active polecats","description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ntmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log origin/main..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `tmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-9g1","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-9g1","depends_on_id":"as-wisp-sq5","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-a3b","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-a3b","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-a3b","depends_on_id":"as-wisp-n7e","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-aab","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and assess queue health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 2a: Track queue non-empty duration**\n\nUse your agent bead labels to track when the MR queue first became non-empty.\nThis persists across patrol cycles and survives session restarts.\n\nResolve your agent bead ID (same as in loop-or-exit step).\n\nRead current state:\n```bash\ngt agent state YOUR_AGENT_BEAD --json\n```\nLook for the `mr_queue_nonempty_since` label.\n\n**If the queue has open MRs:**\n- If `mr_queue_nonempty_since` is NOT set: record the current time.\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --set mr_queue_nonempty_since=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n  ```\n- If `mr_queue_nonempty_since` IS set: calculate how long the queue has been\n  non-empty. Factor this duration into your staleness assessment â€” a queue that\n  has been non-empty for an extended period with no progress is more concerning\n  than one that just became non-empty.\n\n**If the queue is empty (no open MRs):**\n- Clear the timestamp:\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --del mr_queue_nonempty_since\n  ```\n\n**Step 3: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nQueue non-empty since: \u003cmr_queue_nonempty_since or N/A\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-aab","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-aab","depends_on_id":"as-wisp-bh8","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-aun","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-aun","depends_on_id":"as-wisp-2cp","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-aun","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-b56","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-b56","depends_on_id":"as-wisp-6mi","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-b56","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-bd7","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-bd7","depends_on_id":"as-wisp-4g6","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-bd7","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-bh8","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-bh8","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-bh8","depends_on_id":"as-wisp-ny1","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-by5","title":"Inspect all active polecats","description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ntmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log origin/main..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `tmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-by5","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-by5","depends_on_id":"as-wisp-aab","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-cfd","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and assess queue health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 2a: Track queue non-empty duration**\n\nUse your agent bead labels to track when the MR queue first became non-empty.\nThis persists across patrol cycles and survives session restarts.\n\nResolve your agent bead ID (same as in loop-or-exit step).\n\nRead current state:\n```bash\ngt agent state YOUR_AGENT_BEAD --json\n```\nLook for the `mr_queue_nonempty_since` label.\n\n**If the queue has open MRs:**\n- If `mr_queue_nonempty_since` is NOT set: record the current time.\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --set mr_queue_nonempty_since=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n  ```\n- If `mr_queue_nonempty_since` IS set: calculate how long the queue has been\n  non-empty. Factor this duration into your staleness assessment â€” a queue that\n  has been non-empty for an extended period with no progress is more concerning\n  than one that just became non-empty.\n\n**If the queue is empty (no open MRs):**\n- Clear the timestamp:\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --del mr_queue_nonempty_since\n  ```\n\n**Step 3: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nQueue non-empty since: \u003cmr_queue_nonempty_since or N/A\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-cfd","depends_on_id":"as-wisp-89f","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-cfd","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-chj","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-chj","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-chj","depends_on_id":"as-wisp-mnq","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-dk5","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-dk5","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-dk5","depends_on_id":"as-wisp-sx2","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-hk8","title":"Inspect all active polecats","description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ntmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log origin/main..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `tmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-hk8","depends_on_id":"as-wisp-cfd","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-hk8","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-hpk","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-hqe","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-hqe","depends_on_id":"as-wisp-hk8","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-hqe","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-jiv","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-jiv","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-jiv","depends_on_id":"as-wisp-let","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-koq","title":"mol-witness-patrol","description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-l27","title":"Process pending cleanup wisps","description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-l27","depends_on_id":"as-wisp-2cv","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-l27","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-let","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-let","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-let","depends_on_id":"as-wisp-71v","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-mnq","title":"Process witness mail","description":"First, clean up any stale patrol wisps from abnormal exits in previous cycles:\n```bash\nbd mol wisp gc --age 1h\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-mnq","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-n7e","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-n7e","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-n7e","depends_on_id":"as-wisp-aun","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-ny1","title":"Process witness mail","description":"First, clean up any stale patrol wisps from abnormal exits in previous cycles:\n```bash\nbd mol wisp gc --age 1h\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-ny1","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-p0c","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-p0c","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-p0c","depends_on_id":"as-wisp-dk5","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-pix","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-pix","depends_on_id":"as-wisp-8ii","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-pix","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-s5b","title":"Inspect all active polecats","description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ntmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log origin/main..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-\u003crig\u003e-\u003cname\u003e -p | tail -20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `tmux has-session -t =gt-\u003crig\u003e-\u003cname\u003e 2\u003e/dev/null`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:50:58Z","updated_at":"2026-02-23T20:50:58Z","dependencies":[{"issue_id":"as-wisp-s5b","depends_on_id":"as-wisp-5lg","type":"blocks","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-s5b","depends_on_id":"as-wisp-hpk","type":"parent-child","created_at":"2026-02-23T20:50:58Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-sq5","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and assess queue health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 2a: Track queue non-empty duration**\n\nUse your agent bead labels to track when the MR queue first became non-empty.\nThis persists across patrol cycles and survives session restarts.\n\nResolve your agent bead ID (same as in loop-or-exit step).\n\nRead current state:\n```bash\ngt agent state YOUR_AGENT_BEAD --json\n```\nLook for the `mr_queue_nonempty_since` label.\n\n**If the queue has open MRs:**\n- If `mr_queue_nonempty_since` is NOT set: record the current time.\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --set mr_queue_nonempty_since=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n  ```\n- If `mr_queue_nonempty_since` IS set: calculate how long the queue has been\n  non-empty. Factor this duration into your staleness assessment â€” a queue that\n  has been non-empty for an extended period with no progress is more concerning\n  than one that just became non-empty.\n\n**If the queue is empty (no open MRs):**\n- Clear the timestamp:\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --del mr_queue_nonempty_since\n  ```\n\n**Step 3: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nQueue non-empty since: \u003cmr_queue_nonempty_since or N/A\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:15:22Z","updated_at":"2026-02-23T20:15:22Z","dependencies":[{"issue_id":"as-wisp-sq5","depends_on_id":"as-wisp-4hv","type":"parent-child","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-sq5","depends_on_id":"as-wisp-l27","type":"blocks","created_at":"2026-02-23T20:15:22Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-sx2","title":"Check timer gates for expiration","description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-sx2","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-sx2","depends_on_id":"as-wisp-by5","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-tfu","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:47:43Z","updated_at":"2026-02-23T20:47:43Z","dependencies":[{"issue_id":"as-wisp-tfu","depends_on_id":"as-wisp-9ff","type":"parent-child","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-tfu","depends_on_id":"as-wisp-p0c","type":"blocks","created_at":"2026-02-23T20:47:43Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-uaa","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-uaa","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-uaa","depends_on_id":"as-wisp-ymu","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-ugb","title":"End-of-cycle inbox hygiene","description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-ugb","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-ugb","depends_on_id":"as-wisp-jiv","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-ull","title":"Check own context limit","description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-ull","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-ull","depends_on_id":"as-wisp-uaa","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-wjf","title":"Loop or exit for respawn","description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:19Z","updated_at":"2026-02-23T20:53:19Z","dependencies":[{"issue_id":"as-wisp-wjf","depends_on_id":"as-wisp-1dj","type":"parent-child","created_at":"2026-02-23T20:53:18Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-wjf","depends_on_id":"as-wisp-6km","type":"blocks","created_at":"2026-02-23T20:53:19Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-wnk","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-wnk","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-wnk","depends_on_id":"as-wisp-81i","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-xa1","title":"Process witness mail","description":"First, clean up any stale patrol wisps from abnormal exits in previous cycles:\n```bash\nbd mol wisp gc --age 1h\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-xa1","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-yau","title":"Ensure refinery is alive","description":"Ensure the refinery is alive and assess queue health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 2a: Track queue non-empty duration**\n\nUse your agent bead labels to track when the MR queue first became non-empty.\nThis persists across patrol cycles and survives session restarts.\n\nResolve your agent bead ID (same as in loop-or-exit step).\n\nRead current state:\n```bash\ngt agent state YOUR_AGENT_BEAD --json\n```\nLook for the `mr_queue_nonempty_since` label.\n\n**If the queue has open MRs:**\n- If `mr_queue_nonempty_since` is NOT set: record the current time.\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --set mr_queue_nonempty_since=$(date -u +%Y-%m-%dT%H:%M:%SZ)\n  ```\n- If `mr_queue_nonempty_since` IS set: calculate how long the queue has been\n  non-empty. Factor this duration into your staleness assessment â€” a queue that\n  has been non-empty for an extended period with no progress is more concerning\n  than one that just became non-empty.\n\n**If the queue is empty (no open MRs):**\n- Clear the timestamp:\n  ```bash\n  gt agent state YOUR_AGENT_BEAD --del mr_queue_nonempty_since\n  ```\n\n**Step 3: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nQueue non-empty since: \u003cmr_queue_nonempty_since or N/A\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:53:32Z","updated_at":"2026-02-23T20:53:32Z","dependencies":[{"issue_id":"as-wisp-yau","depends_on_id":"as-wisp-6q9","type":"parent-child","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-yau","depends_on_id":"as-wisp-b56","type":"blocks","created_at":"2026-02-23T20:53:31Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-wisp-ymu","title":"Check if active swarm is complete","description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-23T20:45:04Z","updated_at":"2026-02-23T20:45:04Z","dependencies":[{"issue_id":"as-wisp-ymu","depends_on_id":"as-wisp-hqe","type":"blocks","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"},{"issue_id":"as-wisp-ymu","depends_on_id":"as-wisp-koq","type":"parent-child","created_at":"2026-02-23T20:45:03Z","created_by":"witness","metadata":"{}"}],"ephemeral":true,"work_type":"mutex"}
{"id":"as-y6k","title":"Refine client module documentation - reduce AI tone, improve clarity","description":"Review docs/topics/client.dox and client_*.dox files. Remove overly formal/technical phrasing. Add more concrete examples. Cross-reference actual code patterns to ensure accuracy. Focus on: (1) client state machine sections, (2) error recovery patterns, (3) reconnection logic. Do NOT build or test the project, only documentation refinement.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:41:47Z","created_by":"mayor","updated_at":"2026-02-24T01:41:47Z"}
{"id":"as-yzi","title":"Refine video and rendering documentation","description":"Review docs/topics/video.dox, client_display.dox, palette.dox, grid_layout.dox. Simplify rendering pipeline descriptions. Verify SIMD optimization claims. Add display examples. Cross-reference src/common/session/display.c. Replace technical jargon with accessible explanations. Do NOT build or test.","status":"open","priority":2,"issue_type":"task","owner":"me@zfo.gg","created_at":"2026-02-24T01:42:19Z","created_by":"mayor","updated_at":"2026-02-24T01:42:19Z"}
