name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Full version (e.g., v2.0.0) - overrides auto-bump"
        required: false
        type: string
      major_bump:
        description: "Force major version bump (requires manual trigger)"
        required: false
        type: boolean
        default: false

env:
  CC: clang
  CXX: clang++

jobs:
  create-release:
    # Only run for tagged builds or manual dispatch
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for version calculation
          submodules: false

      - name: Initialize submodules
        run: git submodule update --init --depth 1

      - name: Determine version
        id: version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION="${GITHUB_REF#refs/tags/}"
            echo "Using tag-derived version: $VERSION"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Last tag: $LAST_TAG"

            if [[ $LAST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
            else
              MAJOR=0
              MINOR=0
              PATCH=0
            fi

            COMMITS=$(git log --format=%s $LAST_TAG..HEAD)
            BREAKING_COUNT=$(echo "$COMMITS" | grep -icE '^(feat|feature)\!|^breaking' || true)
            BREAKING_BODY_COUNT=$(git log --format=%B $LAST_TAG..HEAD | grep -ic 'BREAKING CHANGE' || true)
            TOTAL_BREAKING=$((BREAKING_COUNT + BREAKING_BODY_COUNT))
            FEAT_COUNT=$(echo "$COMMITS" | grep -icE '^(feat|feature):' || true)
            FIX_COUNT=$(echo "$COMMITS" | grep -icE '^(fix|bugfix):' || true)
            TOTAL_COMMITS=$(echo "$COMMITS" | wc -l)
            OTHER_COUNT=$((TOTAL_COMMITS - TOTAL_BREAKING - FEAT_COUNT - FIX_COUNT))

            echo "Commit analysis:"
            echo "  Breaking changes: $TOTAL_BREAKING"
            echo "  Features: $FEAT_COUNT"
            echo "  Fixes: $FIX_COUNT"
            echo "  Other: $OTHER_COUNT"
            echo "  Total: $TOTAL_COMMITS"

            if [[ "${{ github.event.inputs.major_bump }}" == "true" ]]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              BUMP_TYPE="major (manual override)"
            elif [[ $FEAT_COUNT -gt 0 ]]; then
              MINOR=$((MINOR + FEAT_COUNT))
              PATCH=0
              BUMP_TYPE="minor (${FEAT_COUNT} features)"
            elif [[ $FIX_COUNT -gt 0 || $OTHER_COUNT -gt 0 ]]; then
              PATCH=$((PATCH + FIX_COUNT + OTHER_COUNT))
              BUMP_TYPE="patch (${FIX_COUNT} fixes, ${OTHER_COUNT} other)"
            else
              PATCH=$((PATCH + 1))
              BUMP_TYPE="patch (default)"
            fi

            echo "Bump type: $BUMP_TYPE"
            VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [[ -n "$LAST_TAG" ]]; then
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            echo "## Changes since $LAST_TAG" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            # Group commits by type
            echo "### Features" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -iE '^- (feat|feature):' || echo "- None" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            echo "### Bug Fixes" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -iE '^- (fix|bugfix):' || echo "- None" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            echo "### Other Changes" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -ivE '^- (feat|feature|fix|bugfix):' | head -n 20 >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "CHANGELOG=Initial release of ascii-chat" >> $GITHUB_OUTPUT
          fi

      - name: Create and push tag
        # Only create tag for workflow_dispatch - tag already exists for tag push triggers
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"

      - name: Create release tarball
        id: tarball
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ./scripts/create-release-tarball.sh "$VERSION"
          TARBALL="ascii-chat-${VERSION#v}-full.tar.gz"
          SHA256=$(sha256sum "$TARBALL" | cut -d' ' -f1)
          echo "tarball=$TARBALL" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "Created tarball: $TARBALL"
          echo "SHA256: $SHA256"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: ascii-chat ${{ steps.version.outputs.version }}
          body: |
            # ascii-chat ${{ steps.version.outputs.version }}

            Terminal-based video chat with ASCII art conversion. Supports multiple clients with real-time video mixing and audio streaming.

            ## Download

            **Linux Installers (x86_64 & arm64):**
            - Debian/Ubuntu `.deb`
            - Fedora/RHEL `.rpm`
            - Self-extracting `.sh` installer
            - Portable `.tar.gz`

            **macOS Installers (x86_64 & arm64):**
            - Signed-compatible `.pkg` (productbuild)
            - Portable `.tar.gz`

            **Windows Installers (x86_64):**
            - WiX `.msi` installer
            - Portable `.zip`

            ## Quick Start

            **Linux - Package Manager (no dependencies required):**
            ```bash
            sudo dpkg -i ascii-chat_*.deb         # Debian/Ubuntu
            sudo rpm -i ascii-chat-*.rpm          # Fedora/RHEL
            ```

            **Linux - Self-Extracting Installer:**
            ```bash
            chmod +x ascii-chat-*.sh
            sudo ./ascii-chat-*.sh --prefix=/usr/local
            ```

            **Linux - Portable (.tar.gz):**
            ```bash
            tar -xzf ascii-chat-*.tar.gz
            cd ascii-chat-*/bin
            ./ascii-chat server
            ```

            **macOS - Package Installer:**
            ```bash
            brew install portaudio libsodium      # Install dependencies first
            sudo installer -pkg ascii-chat-*.pkg -target /
            ```

            **macOS - Portable (.tar.gz):**
            ```bash
            brew install portaudio libsodium      # Install dependencies first
            tar -xzf ascii-chat-*.tar.gz
            cd ascii-chat-*/bin
            ./ascii-chat server
            ```

            **Windows - MSI Installer:**
            ```
            msiexec /i ascii-chat-*.msi
            ```

            **Windows - Portable (.zip):**
            ```
            # Extract zip, then run from extracted folder:
            ascii-chat.exe server
            ```

            ## Running ascii-chat

            ```bash
            ascii-chat server  # Start server (in one terminal)
            ascii-chat client  # Connect client (in another terminal)
            ```

            ## Features
            - Real-time webcam to ASCII conversion
            - Multi-client grid layout (up to 9 clients)
            - Audio streaming with mixing
            - Color support (24-bit + 256-color fallback)
            - Half-block rendering for 2x vertical resolution
            - SIMD optimizations (AVX2, SSSE3, SSE2, NEON)
            - Compression support
            - Static builds (Linux) - no dependencies!

            ${{ steps.changelog.outputs.CHANGELOG }}

            ## Source Tarball

            For package maintainers (Homebrew, AUR, etc.):
            - `${{ steps.tarball.outputs.tarball }}`
            - SHA256: `${{ steps.tarball.outputs.sha256 }}`
          draft: false
          prerelease: false
          files: ${{ steps.tarball.outputs.tarball }}
          token: ${{ secrets.GITHUB_TOKEN }}

  package-linux:
    name: Package Linux installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
            arch: x86_64
            artifact_suffix: amd64
          - runner: ubuntu-latest-arm64
            arch: arm64
            artifact_suffix: arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Install build dependencies
        uses: ./.github/actions/install-deps
        with:
          os: ubuntu
          extra-packages: "rpm dpkg-dev fakeroot"

      - name: Configure and package with CPack
        run: |
          cmake --preset release
          cmake --build build_release --target all
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs
          cmake --build build_release --target package

      - name: Print build logs on failure
        if: failure()
        run: |
          echo "=== Defer tool configure log ==="
          cat build_release/ascii-instr-defer-external-prefix/src/ascii-instr-defer-external-stamp/ascii-instr-defer-external-configure-*.log 2>/dev/null || echo "No configure log"
          echo ""
          echo "=== Defer tool build log ==="
          cat build_release/ascii-instr-defer-external-prefix/src/ascii-instr-defer-external-stamp/ascii-instr-defer-external-build-*.log 2>/dev/null || echo "No build log"
          echo ""
          echo "=== CMake error log ==="
          cat build_release/CMakeFiles/CMakeError.log 2>/dev/null || echo "No CMake error log"

      - name: Collect artifacts
        run: |
          mkdir -p dist
          shopt -s nullglob
          for artifact in build_release/*.deb build_release/*.rpm build_release/*.tar.gz build_release/*.sh; do
            [[ -e "$artifact" ]] || continue
            filename=$(basename "$artifact")
            case "$filename" in
              *.tar.gz)
                new_name="${filename%.tar.gz}-${{ matrix.artifact_suffix }}.tar.gz"
                ;;
              *.sh)
                new_name="${filename%.sh}-${{ matrix.artifact_suffix }}.sh"
                ;;
              *.deb)
                new_name="${filename%.deb}-${{ matrix.artifact_suffix }}.deb"
                ;;
              *.rpm)
                new_name="${filename%.rpm}-${{ matrix.artifact_suffix }}.rpm"
                ;;
              *)
                new_name="${filename}-${{ matrix.artifact_suffix }}"
                ;;
            esac
            cp "$artifact" "dist/$new_name"
          done
          ls -l dist

      - name: Upload Linux packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-macos:
    name: Package macOS installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: macos-15-intel
            arch: x86_64
          - os: macos-15
            arch: arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Install build dependencies
        uses: ./.github/actions/install-deps
        with:
          os: macos
          extra-packages: ""

      - name: Configure and package with CPack
        run: |
          # Clean BearSSL build artifacts to ensure fresh build
          rm -rf deps/bearssl/build
          rm -rf .deps-cache/*/bearssl
          make -C deps/bearssl clean || true
          cmake --preset release
          cmake --build build_release --target all
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs
          cmake --build build_release --target package

      - name: Print build logs on failure
        if: failure()
        run: |
          echo "=== BearSSL build log ==="
          cat .deps-cache/*/bearssl/bearssl-build.log 2>/dev/null || echo "No BearSSL build log"
          echo ""
          echo "=== CMake error log ==="
          cat build_release/CMakeFiles/CMakeError.log 2>/dev/null || echo "No CMake error log"

      - name: Collect artifacts
        run: |
          mkdir -p dist
          shopt -s nullglob
          for artifact in build_release/*.pkg build_release/*.tar.gz build_release/*.zip; do
            [[ -e "$artifact" ]] || continue
            filename=$(basename "$artifact")
            case "$filename" in
              *.tar.gz)
                new_name="${filename%.tar.gz}-${{ matrix.arch }}.tar.gz"
                ;;
              *.pkg)
                new_name="${filename%.pkg}-${{ matrix.arch }}.pkg"
                ;;
              *.zip)
                new_name="${filename%.zip}-${{ matrix.arch }}.zip"
                ;;
              *)
                new_name="${filename}-${{ matrix.arch }}"
                ;;
            esac
            cp "$artifact" "dist/$new_name"
          done
          ls -l dist

      - name: Upload macOS packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-windows:
    name: Package Windows installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: "c8696863d371ab7f46e213d8f5ca923c4aef2a00"

      - name: Install dependencies
        uses: ./.github/actions/install-deps
        with:
          os: windows
          vcpkg-packages: "zstd portaudio libsodium"
          vcpkg-static-packages: "zstd portaudio libsodium mimalloc"

      - name: Install WiX toolset
        run: |
          choco install wixtoolset --version=3.11.2 --no-progress -y

      - name: Configure and package with CPack
        shell: pwsh
        run: |
          $toolchain = "$env:VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake"
          cmake --preset release
          cmake --build build_release --target all
          cmake --build build_release --target run-test-static-lib
          cmake --build build_release --target run-test-shared-lib
          cmake --build build_release --target package

      - name: Collect artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $suffix = "x86_64"
          $patterns = @("build_release/*.msi", "build_release/*.zip")
          foreach ($pattern in $patterns) {
            foreach ($artifact in Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue) {
              $name = $artifact.Name
              if ($name.EndsWith(".msi")) {
                $newName = "$($name.Substring(0, $name.Length - 4))-$suffix.msi"
              } elseif ($name.EndsWith(".zip")) {
                $newName = "$($name.Substring(0, $name.Length - 4))-$suffix.zip"
              } else {
                $newName = "$name-$suffix"
              }
              Copy-Item $artifact.FullName (Join-Path dist $newName)
            }
          }
          Get-ChildItem dist

      - name: Upload Windows packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
