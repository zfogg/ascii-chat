name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Full version (e.g., v2.0.0) - overrides auto-bump"
        required: false
        type: string
      major_bump:
        description: "Force major version bump (requires manual trigger)"
        required: false
        type: boolean
        default: false

env:
  CC: clang
  CXX: clang++

jobs:
  create-release:
    # Only run for tagged builds or manual dispatch
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for version calculation
          fetch-tags: true # Explicitly fetch tags for version detection
          submodules: false

      - name: Initialize submodules
        run: git submodule update --init --depth 1

      - name: Determine version
        id: version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION="${GITHUB_REF#refs/tags/}"
            echo "Using tag-derived version: $VERSION"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            # Find highest semantic version tag (not most recent by date)
            # Filter to only vX.Y.Z tags and sort by version number descending
            LAST_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1)
            if [[ -z "$LAST_TAG" ]]; then
              LAST_TAG="v0.0.0"
            fi
            echo "Last tag (highest version): $LAST_TAG"

            if [[ $LAST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
            else
              MAJOR=0
              MINOR=0
              PATCH=0
            fi

            COMMITS=$(git log --format=%s $LAST_TAG..HEAD)
            BREAKING_COUNT=$(echo "$COMMITS" | grep -icE '^(feat|feature)\!|^breaking' || true)
            BREAKING_BODY_COUNT=$(git log --format=%B $LAST_TAG..HEAD | grep -ic 'BREAKING CHANGE' || true)
            TOTAL_BREAKING=$((BREAKING_COUNT + BREAKING_BODY_COUNT))
            FEAT_COUNT=$(echo "$COMMITS" | grep -icE '^(feat|feature):' || true)
            FIX_COUNT=$(echo "$COMMITS" | grep -icE '^(fix|bugfix):' || true)
            TOTAL_COMMITS=$(echo "$COMMITS" | wc -l)
            OTHER_COUNT=$((TOTAL_COMMITS - TOTAL_BREAKING - FEAT_COUNT - FIX_COUNT))

            echo "Commit analysis:"
            echo "  Breaking changes: $TOTAL_BREAKING"
            echo "  Features: $FEAT_COUNT"
            echo "  Fixes: $FIX_COUNT"
            echo "  Other: $OTHER_COUNT"
            echo "  Total: $TOTAL_COMMITS"

            if [[ "${{ github.event.inputs.major_bump }}" == "true" ]]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              BUMP_TYPE="major (manual override)"
            elif [[ $FEAT_COUNT -gt 0 ]]; then
              MINOR=$((MINOR + FEAT_COUNT))
              PATCH=0
              BUMP_TYPE="minor (${FEAT_COUNT} features)"
            elif [[ $FIX_COUNT -gt 0 || $OTHER_COUNT -gt 0 ]]; then
              PATCH=$((PATCH + FIX_COUNT + OTHER_COUNT))
              BUMP_TYPE="patch (${FIX_COUNT} fixes, ${OTHER_COUNT} other)"
            else
              PATCH=$((PATCH + 1))
              BUMP_TYPE="patch (default)"
            fi

            echo "Bump type: $BUMP_TYPE"
            VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_TAG=$(git describe --tags --abbrev=0 --match 'v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "")

          if [[ -n "$LAST_TAG" ]]; then
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            echo "## Changes since $LAST_TAG" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            # Group commits by type
            echo "### Features" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -iE '^- (feat|feature):' || echo "- None" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            echo "### Bug Fixes" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -iE '^- (fix|bugfix):' || echo "- None" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            echo "### Other Changes" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -ivE '^- (feat|feature|fix|bugfix):' | head -n 50 >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "CHANGELOG=Initial release of ascii-chat" >> $GITHUB_OUTPUT
          fi

      - name: Create and push tag
        # Only create tag for workflow_dispatch - tag already exists for tag push triggers
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"

      - name: Create release tarball
        id: tarball
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ./scripts/create-release-tarball.sh "$VERSION"
          TARBALL="ascii-chat-${VERSION#v}-full.tar.gz"
          SHA256=$(sha256sum "$TARBALL" | cut -d' ' -f1)
          echo "tarball=$TARBALL" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "Created tarball: $TARBALL"
          echo "SHA256: $SHA256"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: ascii-chat ${{ steps.version.outputs.version }}
          body: |
            # ascii-chat ${{ steps.version.outputs.version }}

            Terminal-based video chat with ASCII art conversion. Supports multiple clients with real-time video mixing and audio streaming.

            ## Download

            **Two Package Types:**
            - **ascii-chat**: Runtime package (executable + man page + shell completions)
            - **libasciichat**: Development package (libraries + headers + API docs + build integration)

            **Linux Installers (x86_64 & arm64):**
            - Runtime: `ascii-chat-*.deb` or `ascii-chat-*.rpm`
            - Development: `libasciichat-dev-*.deb` or `libasciichat-devel-*.rpm`
            - Documentation: `libasciichat-doc-*.deb` or `libasciichat-doc-*.rpm` (optional)
            - Archives: `ascii-chat-*.tar.gz`, `libasciichat-*.tar.gz`
            - Self-extracting: `ascii-chat-*.sh`, `libasciichat-*.sh`

            **macOS Installers (x86_64 & arm64):**
            - Runtime: `ascii-chat-*.pkg`
            - Development: `libasciichat-*.pkg`
            - Archives: `ascii-chat-*.tar.gz`, `libasciichat-*.tar.gz`
            - Self-extracting: `ascii-chat-*.sh`, `libasciichat-*.sh`

            **Windows Installers (x86_64):**
            - Installer: `ascii-chat-*.msi` (single installer with optional components)
            - Archives: `ascii-chat-*.zip`, `libasciichat-*.zip`

            ## Quick Start

            Choose the architecture of your computer when you download. Ask @claude how to find out your computer's architecture.
            $arch = amd64 (x86_64) or arm64 (aarch64)

            **Linux - Package Manager (no dependencies required):**
            ```bash
            sudo dpkg -i ascii-chat-${{ steps.version.outputs.version }}-$arch.deb         # Debian/Ubuntu
            sudo rpm -i ascii-chat-${{ steps.version.outputs.version }}-$arch.rpm          # Fedora/RHEL
            ```

            **Linux or macOS - Self-Extracting Installer:**
            ```bash
            chmod +x ascii-chat-${{ steps.version.outputs.version }}-$arch.sh
            sudo ./ascii-chat-${{ steps.version.outputs.version }}-$arch.sh --prefix=/usr/local
            ```

            **Linux or macOS - Portable (.tar.gz):**
            ```bash
            tar -xzf ascii-chat-${{ steps.version.outputs.version }}-$arch.tar.gz
            cd ascii-chat-${{ steps.version.outputs.version }}-$arch/bin
            ./ascii-chat server
            ```

            **macOS - Package Installer:**
            ```bash
            sudo installer -pkg ascii-chat-${{ steps.version.outputs.version }}-$arch.pkg -target /
            ```

            **Windows - MSI Installer:**
            ```
            msiexec /i ascii-chat-${{ steps.version.outputs.version }}-$arch.msi
            ```

            **Windows - Portable (.zip):**
            ```
            # Extract zip, then run from extracted folder:
            ascii-chat.exe server
            ```

            ${{ steps.changelog.outputs.CHANGELOG }}

            ## Source Tarball

            For package maintainers (Homebrew, AUR, etc.):
            - `${{ steps.tarball.outputs.tarball }}`
            - SHA256: `${{ steps.tarball.outputs.sha256 }}`
          draft: false
          prerelease: false
          files: ${{ steps.tarball.outputs.tarball }}
          token: ${{ secrets.GITHUB_TOKEN }}

  package-linux:
    name: Package Linux installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
          - runner: ubuntu-latest-arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Install build dependencies
        id: install-deps
        uses: ./.github/actions/install-deps
        with:
          os: ubuntu
          extra-packages: "rpm dpkg-dev fakeroot"

      - name: Verify packaging tools are available
        run: |
          echo "Verifying packaging tools..."
          which dpkg-deb || (echo "ERROR: dpkg-deb not found" && exit 1)
          which rpmbuild || (echo "ERROR: rpmbuild not found" && exit 1)
          dpkg-deb --version
          rpmbuild --version
          echo "All packaging tools verified!"

      - name: Configure with CMake
        run: |
          # Use /usr prefix for Linux (FHS compliance, matches DEB/RPM packages)
          # This ensures paths.h has the correct prefix baked in for system config
          cmake --preset release -DCMAKE_INSTALL_PREFIX=/usr

      - name: Save CMake dependency cache
        if: always() && steps.install-deps.outputs.cmake-cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            .deps-cache
            deps/bearssl/build
          key: ${{ steps.install-deps.outputs.cmake-cache-key }}

      - name: Build and package with CPack
        run: |
          cmake --build build_release --target all
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs

          # Run CPack with verbose output to diagnose DEB/RPM generation issues
          cd build_release
          cpack --verbose

      - name: Print build logs on failure
        if: failure()
        run: |
          echo "=== Defer tool configure log ==="
          cat build_release/ascii-instr-defer-external-prefix/src/ascii-instr-defer-external-stamp/ascii-instr-defer-external-configure-*.log 2>/dev/null || echo "No configure log"
          echo ""
          echo "=== Defer tool build log ==="
          cat build_release/ascii-instr-defer-external-prefix/src/ascii-instr-defer-external-stamp/ascii-instr-defer-external-build-*.log 2>/dev/null || echo "No build log"
          echo ""
          echo "=== CMake error log ==="
          cat build_release/CMakeFiles/CMakeError.log 2>/dev/null || echo "No CMake error log"

      - name: Print ccache stats
        if: always()
        run: ccache --show-stats || true

      - name: Save ccache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .ccache
          key: ${{ steps.install-deps.outputs.ccache-key }}

      - name: Save build directory
        if: always()
        uses: actions/cache/save@v4
        with:
          path: build_release
          key: ${{ steps.install-deps.outputs.build-cache-key }}

      - name: Collect artifacts
        run: |
          mkdir -p dist
          shopt -s nullglob

          # Copy all package artifacts (component-based packaging creates multiple packages)
          # Expected packages per architecture:
          #   - ascii-chat-*.deb (runtime package)
          #   - libasciichat-dev-*.deb (development package)
          #   - libasciichat-doc-*.deb (documentation package, arch=all)
          #   - ascii-chat-*.rpm (runtime package)
          #   - libasciichat-devel-*.rpm (development package)
          #   - libasciichat-doc-*.rpm (documentation package, arch=noarch)
          #   - ascii-chat-*.tar.gz (runtime archive)
          #   - libasciichat-*.tar.gz (development archive)
          #   - ascii-chat-*.sh (runtime self-extracting installer)
          #   - libasciichat-*.sh (development self-extracting installer)
          for artifact in build_release/*.deb build_release/*.rpm build_release/*.tar.gz build_release/*.sh; do
            [[ -e "$artifact" ]] || continue
            cp "$artifact" dist/
          done

          # Verify required package types exist
          echo "Checking for required package types..."
          ls -l dist

          missing=""
          ls dist/*ascii-chat*.deb 1>/dev/null 2>&1 || missing="$missing ascii-chat.deb"
          ls dist/*libasciichat*.deb 1>/dev/null 2>&1 || missing="$missing libasciichat.deb"
          ls dist/*ascii-chat*.rpm 1>/dev/null 2>&1 || missing="$missing ascii-chat.rpm"
          ls dist/*libasciichat*.rpm 1>/dev/null 2>&1 || missing="$missing libasciichat.rpm"
          ls dist/*ascii-chat*.tar.gz 1>/dev/null 2>&1 || missing="$missing ascii-chat.tar.gz"
          ls dist/*libasciichat*.tar.gz 1>/dev/null 2>&1 || missing="$missing libasciichat.tar.gz"
          ls dist/*ascii-chat*.sh 1>/dev/null 2>&1 || missing="$missing ascii-chat.sh"
          ls dist/*libasciichat*.sh 1>/dev/null 2>&1 || missing="$missing libasciichat.sh"

          if [[ -n "$missing" ]]; then
            echo "::error::Missing required packages:$missing"
            exit 1
          fi
          echo "All required packages found (runtime + development)"

      - name: Upload Linux packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-macos:
    name: Package macOS installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: macos-15-intel
          - os: macos-15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Install build dependencies
        id: install-deps
        uses: ./.github/actions/install-deps
        with:
          os: macos
          extra-packages: ""

      - name: Configure with CMake
        run: cmake --preset release

      - name: Save CMake dependency cache
        if: always() && steps.install-deps.outputs.cmake-cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            .deps-cache
            deps/bearssl/build
          key: ${{ steps.install-deps.outputs.cmake-cache-key }}

      - name: Build and package with CPack
        run: |
          cmake --build build_release --target all
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs
          cmake --build build_release --target package

      - name: Print ccache stats
        if: always()
        run: ccache --show-stats || true

      - name: Save ccache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .ccache
          key: ${{ steps.install-deps.outputs.ccache-key }}

      - name: Save build directory
        if: always()
        uses: actions/cache/save@v4
        with:
          path: build_release
          key: ${{ steps.install-deps.outputs.build-cache-key }}

      - name: Collect artifacts
        run: |
          mkdir -p dist
          shopt -s nullglob

          # Copy all package artifacts (component-based packaging creates multiple packages)
          # Expected packages per architecture:
          #   - ascii-chat-*.pkg (runtime package)
          #   - libasciichat-*.pkg (development package)
          #   - ascii-chat-*.tar.gz (runtime archive)
          #   - libasciichat-*.tar.gz (development archive)
          #   - ascii-chat-*.sh (runtime self-extracting installer)
          #   - libasciichat-*.sh (development self-extracting installer)
          for artifact in build_release/*.pkg build_release/*.tar.gz build_release/*.sh; do
            [[ -e "$artifact" ]] || continue
            cp "$artifact" dist/
          done

          # Verify required package types exist
          echo "Checking for required package types..."
          ls -l dist

          missing=""
          ls dist/*ascii-chat*.pkg 1>/dev/null 2>&1 || missing="$missing ascii-chat.pkg"
          ls dist/*libasciichat*.pkg 1>/dev/null 2>&1 || missing="$missing libasciichat.pkg"
          ls dist/*ascii-chat*.tar.gz 1>/dev/null 2>&1 || missing="$missing ascii-chat.tar.gz"
          ls dist/*libasciichat*.tar.gz 1>/dev/null 2>&1 || missing="$missing libasciichat.tar.gz"
          ls dist/*ascii-chat*.sh 1>/dev/null 2>&1 || missing="$missing ascii-chat.sh"
          ls dist/*libasciichat*.sh 1>/dev/null 2>&1 || missing="$missing libasciichat.sh"

          if [[ -n "$missing" ]]; then
            echo "::error::Missing required packages:$missing"
            exit 1
          fi
          echo "All required packages found (runtime + development)"

      - name: Upload macOS packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-windows:
    name: Package Windows installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Verify and clean BearSSL submodule
        shell: pwsh
        run: |
          # Verify BearSSL source files exist (debug for CI issues)
          Write-Host "=== BearSSL submodule verification ==="
          Write-Host "Checking if deps/bearssl exists..."
          if (!(Test-Path "deps/bearssl")) {
            Write-Host "ERROR: deps/bearssl directory not found!"
            exit 1
          }
          Write-Host "Checking if deps/bearssl/src/aead/ccm.c exists..."
          if (!(Test-Path "deps/bearssl/src/aead/ccm.c")) {
            Write-Host "ERROR: deps/bearssl/src/aead/ccm.c not found!"
            Write-Host "Contents of deps/bearssl:"
            Get-ChildItem -Path "deps/bearssl" -Recurse | Select-Object -First 50
            exit 1
          }
          Write-Host "BearSSL source files verified OK"

          Write-Host "BearSSL ready for build"

      - name: Install dependencies
        id: install-deps
        uses: ./.github/actions/install-deps
        with:
          os: windows
          vcpkg-packages: "zstd portaudio libsodium opus speexdsp"
          vcpkg-static-packages: "zstd portaudio libsodium opus speexdsp mimalloc"
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install WiX toolset
        run: |
          choco install wixtoolset --no-progress -y

      - name: Configure with CMake
        shell: pwsh
        run: |
          $deferTool = "${{ steps.install-deps.outputs.defer-tool-path }}"
          # Disable analyzers - GitHub Actions Windows runner has broken cppcheck from Strawberry Perl
          cmake --preset release -DASCIICHAT_DEFER_TOOL="$deferTool" -DASCIICHAT_ENABLE_ANALYZERS=OFF

      - name: Save CMake dependency cache
        if: always() && steps.install-deps.outputs.cmake-cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: |
            .deps-cache
            deps/bearssl/build
          key: ${{ steps.install-deps.outputs.cmake-cache-key }}

      - name: Build and package with CPack
        shell: pwsh
        run: |
          cmake --build build_release --target ascii-chat
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs
          cmake --build build_release --target package

      - name: Print ccache stats
        if: always()
        shell: bash
        run: ccache --show-stats || true

      - name: Save ccache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .ccache
          key: ${{ steps.install-deps.outputs.ccache-key }}

      - name: Save build directory
        if: always()
        uses: actions/cache/save@v4
        with:
          path: build_release
          key: ${{ steps.install-deps.outputs.build-cache-key }}

      - name: Collect artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null

          # Copy all package artifacts (component-based packaging creates multiple packages)
          # Expected packages:
          #   - ascii-chat.msi (runtime package - single installer with optional components)
          #   - ascii-chat-*.zip (runtime archive)
          #   - libasciichat-*.zip (development archive)
          # Note: WIX creates a single .msi with selectable components, not separate .msi files
          $patterns = @("build_release/*.msi", "build_release/*.zip")
          foreach ($pattern in $patterns) {
            foreach ($artifact in Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue) {
              Copy-Item $artifact.FullName dist/
            }
          }

          # Verify required package types exist
          Write-Host "Checking for required package types..."
          Get-ChildItem dist

          $missing = @()
          if (-not (Get-ChildItem dist/*.msi -ErrorAction SilentlyContinue)) { $missing += "ascii-chat.msi" }
          if (-not (Get-ChildItem dist/*ascii-chat*.zip -ErrorAction SilentlyContinue)) { $missing += "ascii-chat.zip" }
          if (-not (Get-ChildItem dist/*libasciichat*.zip -ErrorAction SilentlyContinue)) { $missing += "libasciichat.zip" }

          if ($missing.Count -gt 0) {
            Write-Host "::error::Missing required packages: $($missing -join ', ')"
            exit 1
          }
          Write-Host "All required packages found (runtime + development)"

      - name: Upload Windows packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
