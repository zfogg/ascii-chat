name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Full version (e.g., v2.0.0) - overrides auto-bump"
        required: false
        type: string
      major_bump:
        description: "Force major version bump (requires manual trigger)"
        required: false
        type: boolean
        default: false

env:
  CC: clang
  CXX: clang++

jobs:
  create-release:
    # Only run for tagged builds or manual dispatch
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for version calculation
          submodules: false

      - name: Initialize submodules
        run: git submodule update --init --depth 1

      - name: Determine version
        id: version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION="${GITHUB_REF#refs/tags/}"
            echo "Using tag-derived version: $VERSION"
          elif [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $VERSION"
          else
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Last tag: $LAST_TAG"

            if [[ $LAST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
            else
              MAJOR=0
              MINOR=0
              PATCH=0
            fi

            COMMITS=$(git log --format=%s $LAST_TAG..HEAD)
            BREAKING_COUNT=$(echo "$COMMITS" | grep -icE '^(feat|feature)\!|^breaking' || true)
            BREAKING_BODY_COUNT=$(git log --format=%B $LAST_TAG..HEAD | grep -ic 'BREAKING CHANGE' || true)
            TOTAL_BREAKING=$((BREAKING_COUNT + BREAKING_BODY_COUNT))
            FEAT_COUNT=$(echo "$COMMITS" | grep -icE '^(feat|feature):' || true)
            FIX_COUNT=$(echo "$COMMITS" | grep -icE '^(fix|bugfix):' || true)
            TOTAL_COMMITS=$(echo "$COMMITS" | wc -l)
            OTHER_COUNT=$((TOTAL_COMMITS - TOTAL_BREAKING - FEAT_COUNT - FIX_COUNT))

            echo "Commit analysis:"
            echo "  Breaking changes: $TOTAL_BREAKING"
            echo "  Features: $FEAT_COUNT"
            echo "  Fixes: $FIX_COUNT"
            echo "  Other: $OTHER_COUNT"
            echo "  Total: $TOTAL_COMMITS"

            if [[ "${{ github.event.inputs.major_bump }}" == "true" ]]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              BUMP_TYPE="major (manual override)"
            elif [[ $FEAT_COUNT -gt 0 ]]; then
              MINOR=$((MINOR + FEAT_COUNT))
              PATCH=0
              BUMP_TYPE="minor (${FEAT_COUNT} features)"
            elif [[ $FIX_COUNT -gt 0 || $OTHER_COUNT -gt 0 ]]; then
              PATCH=$((PATCH + FIX_COUNT + OTHER_COUNT))
              BUMP_TYPE="patch (${FIX_COUNT} fixes, ${OTHER_COUNT} other)"
            else
              PATCH=$((PATCH + 1))
              BUMP_TYPE="patch (default)"
            fi

            echo "Bump type: $BUMP_TYPE"
            VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [[ -n "$LAST_TAG" ]]; then
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            echo "## Changes since $LAST_TAG" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            # Group commits by type
            echo "### Features" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -iE '^- (feat|feature):' || echo "- None" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            echo "### Bug Fixes" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -iE '^- (fix|bugfix):' || echo "- None" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT

            echo "### Other Changes" >> $GITHUB_OUTPUT
            git log --format="- %s (%an)" $LAST_TAG..HEAD | grep -ivE '^- (feat|feature|fix|bugfix):' | head -n 50 >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "CHANGELOG=Initial release of ascii-chat" >> $GITHUB_OUTPUT
          fi

      - name: Create and push tag
        # Only create tag for workflow_dispatch - tag already exists for tag push triggers
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"

      - name: Create release tarball
        id: tarball
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ./scripts/create-release-tarball.sh "$VERSION"
          TARBALL="ascii-chat-${VERSION#v}-full.tar.gz"
          SHA256=$(sha256sum "$TARBALL" | cut -d' ' -f1)
          echo "tarball=$TARBALL" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "Created tarball: $TARBALL"
          echo "SHA256: $SHA256"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: ascii-chat ${{ steps.version.outputs.version }}
          body: |
            # ascii-chat ${{ steps.version.outputs.version }}

            Terminal-based video chat with ASCII art conversion. Supports multiple clients with real-time video mixing and audio streaming.

            ## Download

            **Linux Installers (x86_64 & arm64):**
            - Debian/Ubuntu `.deb`
            - Fedora/RHEL `.rpm`
            - Self-extracting `.sh` installer
            - Portable `.tar.gz`

            **macOS Installers (x86_64 & arm64):**
            - Signed-compatible `.pkg` (productbuild)
            - Portable `.tar.gz`

            **Windows Installers (x86_64):**
            - WiX `.msi` installer
            - Portable `.zip`

            ## Quick Start

            Choose the architecture of your computer when you download. Ask @claude how to find out your computer's architecture.
            $arch = amd64 (x86_64) or arm64 (aarch64)

            **Linux - Package Manager (no dependencies required):**
            ```bash
            sudo dpkg -i ascii-chat-${{ steps.version.outputs.version }}-$arch.deb         # Debian/Ubuntu
            sudo rpm -i ascii-chat-${{ steps.version.outputs.version }}-$arch.rpm          # Fedora/RHEL
            ```

            **Linux - Self-Extracting Installer:**
            ```bash
            chmod +x ascii-chat-${{ steps.version.outputs.version }}-$arch.sh
            sudo ./ascii-chat-${{ steps.version.outputs.version }}-$arch.sh --prefix=/usr/local
            ```

            **Linux or macOS - Portable (.tar.gz):**
            ```bash
            tar -xzf ascii-chat-${{ steps.version.outputs.version }}-$arch.tar.gz
            cd ascii-chat-${{ steps.version.outputs.version }}-$arch/bin
            ./ascii-chat server
            ```

            **macOS - Package Installer:**
            ```bash
            sudo installer -pkg ascii-chat-${{ steps.version.outputs.version }}-$arch.pkg -target /
            ```

            **Windows - MSI Installer:**
            ```
            msiexec /i ascii-chat-${{ steps.version.outputs.version }}-$arch.msi
            ```

            **Windows - Portable (.zip):**
            ```
            # Extract zip, then run from extracted folder:
            ascii-chat.exe server
            ```

            ${{ steps.changelog.outputs.CHANGELOG }}

            ## Source Tarball

            For package maintainers (Homebrew, AUR, etc.):
            - `${{ steps.tarball.outputs.tarball }}`
            - SHA256: `${{ steps.tarball.outputs.sha256 }}`
          draft: false
          prerelease: false
          files: ${{ steps.tarball.outputs.tarball }}
          token: ${{ secrets.GITHUB_TOKEN }}

  package-linux:
    name: Package Linux installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
          - runner: ubuntu-latest-arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Install build dependencies
        uses: ./.github/actions/install-deps
        with:
          os: ubuntu
          extra-packages: "rpm dpkg-dev fakeroot"

      - name: Configure and package with CPack
        run: |
          cmake --preset release
          cmake --build build_release --target all
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs
          cmake --build build_release --target package

      - name: Print build logs on failure
        if: failure()
        run: |
          echo "=== Defer tool configure log ==="
          cat build_release/ascii-instr-defer-external-prefix/src/ascii-instr-defer-external-stamp/ascii-instr-defer-external-configure-*.log 2>/dev/null || echo "No configure log"
          echo ""
          echo "=== Defer tool build log ==="
          cat build_release/ascii-instr-defer-external-prefix/src/ascii-instr-defer-external-stamp/ascii-instr-defer-external-build-*.log 2>/dev/null || echo "No build log"
          echo ""
          echo "=== CMake error log ==="
          cat build_release/CMakeFiles/CMakeError.log 2>/dev/null || echo "No CMake error log"

      - name: Collect artifacts
        run: |
          mkdir -p dist
          shopt -s nullglob
          # CPack already includes architecture in filename, just copy
          for artifact in build_release/*.deb build_release/*.rpm build_release/*.tar.gz build_release/*.sh; do
            [[ -e "$artifact" ]] || continue
            cp "$artifact" dist/
          done
          ls -l dist

      - name: Upload Linux packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-macos:
    name: Package macOS installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: macos-15-intel
          - os: macos-15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Install build dependencies
        uses: ./.github/actions/install-deps
        with:
          os: macos
          extra-packages: ""

      - name: Configure and package with CPack
        run: |
          # Clean BearSSL build artifacts to ensure fresh build
          rm -rf deps/bearssl/build
          rm -rf .deps-cache/*/bearssl
          make -C deps/bearssl clean || true
          cmake --preset release
          cmake --build build_release --target all
          cmake --build build_release --target static-lib
          cmake --build build_release --target shared-lib
          cmake --build build_release --target docs
          cmake --build build_release --target package

      - name: Print build logs on failure
        if: failure()
        run: |
          echo "=== Cache directory structure ==="
          find .deps-cache -type f -name "*.log" 2>/dev/null || echo "No log files in .deps-cache"
          echo ""
          echo "=== BearSSL build log (cache) ==="
          for f in .deps-cache/*/bearssl/bearssl-build.log; do
            if [[ -f "$f" ]]; then
              echo "--- $f ---"
              cat "$f"
            fi
          done || echo "No BearSSL build log in cache"
          echo ""
          echo "=== BearSSL source build directory ==="
          ls -la deps/bearssl/build/ 2>/dev/null || echo "No deps/bearssl/build directory"
          echo ""
          echo "=== Compiler and AR info ==="
          which clang && clang --version | head -1
          which llvm-ar && llvm-ar --version | head -1 || echo "llvm-ar not found, using ar"
          which ar && ar --version | head -1
          echo ""
          echo "=== Try rebuilding BearSSL with verbose output ==="
          make -C deps/bearssl clean 2>/dev/null || true
          # Show full output including ar step (not just first 100 lines)
          make -C deps/bearssl lib CC="$(which clang)" AR="$(which llvm-ar || which ar)" CFLAGS="-fPIC" 2>&1
          echo ""
          echo "=== Verify BearSSL was built ==="
          ls -la deps/bearssl/build/libbearssl.a 2>/dev/null || echo "libbearssl.a was not created"
          echo ""
          echo "=== CMake error log ==="
          cat build_release/CMakeFiles/CMakeError.log 2>/dev/null || echo "No CMake error log"

      - name: Collect artifacts
        run: |
          mkdir -p dist
          shopt -s nullglob
          # CPack already includes architecture in filename, just copy
          for artifact in build_release/*.pkg build_release/*.tar.gz build_release/*.zip; do
            [[ -e "$artifact" ]] || continue
            cp "$artifact" dist/
          done
          ls -l dist

      - name: Upload macOS packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  package-windows:
    name: Package Windows installers
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    needs: create-release
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          fetch-tags: true
          submodules: true
          ref: ${{ needs.create-release.outputs.version }}

      - name: Verify and clean BearSSL submodule
        shell: pwsh
        run: |
          # Verify BearSSL source files exist (debug for CI issues)
          Write-Host "=== BearSSL submodule verification ==="
          Write-Host "Checking if deps/bearssl exists..."
          if (!(Test-Path "deps/bearssl")) {
            Write-Host "ERROR: deps/bearssl directory not found!"
            exit 1
          }
          Write-Host "Checking if deps/bearssl/src/aead/ccm.c exists..."
          if (!(Test-Path "deps/bearssl/src/aead/ccm.c")) {
            Write-Host "ERROR: deps/bearssl/src/aead/ccm.c not found!"
            Write-Host "Contents of deps/bearssl:"
            Get-ChildItem -Path "deps/bearssl" -Recurse | Select-Object -First 50
            exit 1
          }
          Write-Host "BearSSL source files verified OK"

          # Clean any stale BearSSL build state
          Write-Host "Cleaning BearSSL build directory..."
          if (Test-Path "deps/bearssl/build") {
            Remove-Item -Recurse -Force "deps/bearssl/build"
          }
          Write-Host "BearSSL ready for build"

      - name: Setup vcpkg
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: "80d025e8299d442c13b29751fc9451711b7c6c8e"

      - name: Install dependencies
        uses: ./.github/actions/install-deps
        with:
          os: windows
          vcpkg-packages: "zstd portaudio libsodium"
          vcpkg-static-packages: "zstd portaudio libsodium mimalloc"

      - name: Install WiX toolset
        run: |
          choco install wixtoolset --no-progress -y

      - name: Download pre-built defer tool
        shell: pwsh
        run: |
          # Download pre-built defer tool and its DLL dependencies from build-tools release
          # This avoids needing full LLVM dev libraries which aren't available in standard Windows LLVM packages
          $deferToolDir = Join-Path $PWD ".deps-cache" "defer-tool"
          New-Item -ItemType Directory -Force -Path $deferToolDir | Out-Null
          gh release download build-tools --pattern "ascii-instr-defer-Windows-AMD64.exe" --dir $deferToolDir
          gh release download build-tools --pattern "zlib1.dll" --dir $deferToolDir
          gh release download build-tools --pattern "zstd.dll" --dir $deferToolDir
          $srcPath = Join-Path $deferToolDir "ascii-instr-defer-Windows-AMD64.exe"
          $dstPath = Join-Path $deferToolDir "ascii-instr-defer.exe"
          Move-Item -Path $srcPath -Destination $dstPath -Force
          Write-Host "Downloaded defer tool to: $dstPath"
          Write-Host "Downloaded DLLs: zlib1.dll, zstd.dll"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download pre-built BearSSL
        shell: pwsh
        run: |
          # Download pre-built BearSSL from build-tools release
          # This avoids nmake build issues with shallow clones of BearSSL submodule
          $bearsslDir = Join-Path $PWD ".deps-cache" "Release" "bearssl"
          New-Item -ItemType Directory -Force -Path $bearsslDir | Out-Null
          gh release download build-tools --pattern "bearssls-Windows-AMD64.lib" --dir $bearsslDir
          $srcPath = Join-Path $bearsslDir "bearssls-Windows-AMD64.lib"
          $dstPath = Join-Path $bearsslDir "bearssls.lib"
          Move-Item -Path $srcPath -Destination $dstPath -Force
          Write-Host "Downloaded BearSSL to: $dstPath"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure and package with CPack
        shell: pwsh
        run: |
          $deferTool = Join-Path $PWD ".deps-cache" "defer-tool" "ascii-instr-defer.exe"
          cmake --preset release -DASCIICHAT_DEFER_TOOL="$deferTool"
          cmake --build build_release --target all --verbose
          cmake --build build_release --target run-test-static-lib --verbose
          cmake --build build_release --target run-test-shared-lib --verbose
          cmake --build build_release --target package --verbose

      - name: Collect artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          # CPack already includes architecture in filename, just copy
          $patterns = @("build_release/*.msi", "build_release/*.zip")
          foreach ($pattern in $patterns) {
            foreach ($artifact in Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue) {
              Copy-Item $artifact.FullName dist/
            }
          }
          Get-ChildItem dist

      - name: Upload Windows packages to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
