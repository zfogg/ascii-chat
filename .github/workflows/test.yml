name: Test Suite

on:
  push:
    branches: [ main, master ]
    paths:
      - '**.c'
      - '**.h'
      - '**.m'
      - 'tests/**'
      - 'CMakeLists.txt'
      - 'cmake/**'
      - '.github/workflows/test.yml'
  pull_request:
    branches: [ '*' ]
    paths:
      - '**.c'
      - '**.h'
      - '**.m'
      - 'tests/**'
      - 'CMakeLists.txt'
      - 'cmake/**'
      - '.github/workflows/test.yml'

permissions:
  contents: read
  issues: read
  checks: write
  pull-requests: write

env:
  CC: clang
  CXX: clang++

jobs:
  unit-tests:
    name: Unit Tests
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-15]
        build_type: [debug, release]
        include:
          - os: ubuntu-latest
            os-name: ubuntu
          - os: macos-15
            os-name: macos

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        fetch-tags: true
        submodules: true

    - name: Install dependencies with caching
      uses: ./.github/actions/install-deps
      with:
        os: ${{ matrix.os-name }}
        extra-packages: ${{ matrix.os-name == 'ubuntu' && 'lcov gcovr libc6-dbg' || 'gcovr' }}

    - name: Cache build, dependencies, and ccache
      id: cache-build
      uses: ./.github/actions/cache-build
      with:
        cache-version: v5
        build-cache-key: ${{ matrix.build_type }}

    - name: Clean build directory to force reconfigure
      run: |
        rm -rf build/CMakeCache.txt build/CMakeFiles
        # Also clean test executables to ensure they're rebuilt with correct configuration
        rm -rf build/bin/test_*
        # Clean library files to prevent stale archive format issues when switching build types
        rm -rf build/lib/*.a

    - name: Build test suite (${{ matrix.build_type }})
      run: |
        # Use CMake build system
        BUILD_TYPE=${{ matrix.build_type == 'debug' && 'Debug' || 'Release' }}

        # Set additional C flags based on build type
        if [ "${{ matrix.build_type }}" = "debug" ]; then
          EXTRA_FLAGS="--coverage"
        else
          EXTRA_FLAGS=""
        fi

        # Use Homebrew LLVM on macOS for better standards support
        # Detect Homebrew prefix (ARM Mac uses /opt/homebrew, Intel uses /usr/local)
        if [ "${{ matrix.os-name }}" = "macos" ]; then
          if [ -d "/opt/homebrew/opt/llvm" ]; then
            HOMEBREW_PREFIX="/opt/homebrew"
          elif [ -d "/usr/local/opt/llvm" ]; then
            HOMEBREW_PREFIX="/usr/local"
          else
            echo "Error: Homebrew LLVM not found at /opt/homebrew or /usr/local"
            exit 1
          fi
          CLANG_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang"
          CLANGXX_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang++"
          echo "Using Homebrew LLVM from: ${HOMEBREW_PREFIX}/opt/llvm"
        else
          CLANG_BIN="clang"
          CLANGXX_BIN="clang++"
        fi

        FLAGS="-std=c2x"
        if [ -n "${EXTRA_FLAGS}" ]; then
          FLAGS="${FLAGS} ${EXTRA_FLAGS}"
        fi

        echo "Building with CMake build type: ${BUILD_TYPE}"
        cmake_args=(
          --preset github
          -DCMAKE_C_COMPILER="${CLANG_BIN}"
          -DCMAKE_CXX_COMPILER="${CLANGXX_BIN}"
          -DCMAKE_BUILD_TYPE=${BUILD_TYPE}
          -DCMAKE_C_FLAGS="${FLAGS}"
        )

        if [ "${BUILD_TYPE}" = "Release" ]; then
          cmake_args+=(-DASCIICHAT_ENFORCE_STATIC_RELEASE=OFF)
          # Force Criterion tests in Release mode for CI testing
          # Must use ASCIICHAT_FORCE_CRITERION_TESTS (cache option) not BUILD_CRITERION_TESTS (regular variable)
          cmake_args+=(-DASCIICHAT_FORCE_CRITERION_TESTS=ON)
        fi

        cmake -B build "${cmake_args[@]}"
        # Use --verbose to see full compile commands for debugging tooling build issues
        cmake --build build --verbose 2>&1 | tee build_output.log || {
          echo "Build failed. Extracting tooling compile commands..."
          grep -A 5 -B 5 "ascii-instr-defer\|ascii-instr-panic\|tool.cpp" build_output.log | head -100 || true
          exit 1
        }

        echo "Test executables built:"
        ls -la build/bin/test_* 2>/dev/null || echo "No test executables found in build/bin/"
        echo "All files in build/bin:"
        ls -la build/bin/ 2>/dev/null || echo "build/bin/ directory not found"

        # Debug: Check if coverage build actually created .gcno files
        if [ "${{ matrix.build_type }}" = "debug" ]; then
          echo "DEBUG: Coverage build - checking for .gcno files..."
          echo "DEBUG: Count of .gcno files after build: $(find . -name "*.gcno" -type f | wc -l)"
          echo "DEBUG: Sample .gcno files:"
          find . -name "*.gcno" -type f | head -5
        fi

    - name: Run unit tests with JUnit XML generation
      run: |
        echo "Running tests with build type: ${{ matrix.build_type }}"
        echo "Looking for test executables:"
        find . -name "test_unit_*" -type f 2>/dev/null | head -10
        # Save logs with descriptive filename
        LOG_FILE="unit-tests-${{ matrix.os-name }}-${{ matrix.build_type }}.log"
        ./tests/scripts/run_tests.sh -t unit -b ${{ matrix.build_type }} -J --log-file="${LOG_FILE}"
        echo "Unit tests completed successfully"
        echo "Test logs saved to: ${LOG_FILE}"

    - name: Generate coverage report (debug builds only)
      if: always() && matrix.build_type == 'debug'
      run: |
        # Generate coverage files for codecov (coverage builds create .gcda files)
        echo "Looking for .gcda files to generate coverage from..."
        find . -name "*.gcda" -type f | head -10

        if find . -name "*.gcda" -type f | head -1 > /dev/null 2>&1; then
          echo "Found .gcda files, generating coverage..."

          # Debug: Check .gcno files
          echo "DEBUG: Checking .gcno files..."
          echo "DEBUG: Count of .gcno files: $(find . -name "*.gcno" -type f | wc -l)"
          echo "DEBUG: Sample .gcno files:"
          find . -name "*.gcno" -type f | head -5

          # Debug: Check .gcda files
          echo "DEBUG: Count of .gcda files: $(find . -name "*.gcda" -type f | wc -l)"
          echo "DEBUG: Sample .gcda files:"
          find . -name "*.gcda" -type f | head -5

          # Debug: Check if we have matching .gcno/.gcda pairs
          echo "DEBUG: Checking for matching .gcno/.gcda pairs..."
          for gcda in $(find . -name "*.gcda" -type f | head -3); do
            gcno="${gcda%.gcda}.gcno"
            echo "DEBUG: Checking pair: $gcda -> $gcno"
            if [ -f "$gcno" ]; then
              echo "DEBUG: ✅ Pair exists"
              ls -la "$gcno" "$gcda"
            else
              echo "DEBUG: ❌ Missing .gcno file for $gcda"
            fi
          done

          # Generate coverage using reusable action would go here, but we need inline for conditional
          echo "DEBUG: Running coverage tool on .gcda files..."
          # Use gcov on macOS, llvm-cov on Ubuntu
          # Use -p to preserve path components and avoid overwriting files with same basename
          if [ "${{ matrix.os-name }}" = "macos" ]; then
            echo "DEBUG: Using gcov (macOS)"
            find . -name "*.gcda" -exec gcov -p {} \;
          else
            echo "DEBUG: Using llvm-cov (Ubuntu)"
            find . -name "*.gcda" -exec sh -c 'llvm-cov gcov -p "$1"' _ {} \;
          fi
          echo "DEBUG: Coverage command completed"

          # Debug: Check where .gcov files were created
          echo "DEBUG: Looking for .gcov files after coverage execution..."
          echo "DEBUG: All .gcov files found:"
          find . -name "*.gcov" -type f -exec ls -la {} \;
          echo "DEBUG: Count of .gcov files: $(find . -name "*.gcov" -type f | wc -l)"

          # Move all .gcov files to repo root for consistent behavior across platforms
          echo "Moving .gcov files to repo root..."
          echo "DEBUG: Before move - .gcov files in root: $(ls -la *.gcov 2>/dev/null | wc -l || echo 0)"
          find . -name "*.gcov" -type f -exec mv {} . \; || false
          echo "DEBUG: Move command completed"

          # Show what coverage files were generated
          echo "Generated coverage files:"
          echo "DEBUG: After move - .gcov files in root: $(ls -la *.gcov 2>/dev/null | wc -l || echo 0)"
          find . -name "*.gcov" -type f | head -20
          ls -la *.gcov 2>/dev/null
        else
          echo "No .gcda files found (this is expected for non-coverage builds)"
        fi

    - name: Save build caches
      if: always()
      uses: ./.github/actions/cache-build-save
      with:
        build-directory: ${{ steps.cache-build.outputs['build-directory-path'] }}
        build-cache-key: ${{ steps.cache-build.outputs['build-cache-key'] }}
        build-cache-hit: ${{ steps.cache-build.outputs['build-cache-hit'] }}
        cache-deps-enabled: ${{ steps.cache-build.outputs['cache-deps-enabled'] }}
        deps-cache-directory: ${{ steps.cache-build.outputs['deps-cache-path'] }}
        deps-cache-key: ${{ steps.cache-build.outputs['deps-cache-key'] }}
        deps-cache-hit: ${{ steps.cache-build.outputs['deps-cache-hit'] }}
        cache-ccache-enabled: ${{ steps.cache-build.outputs['cache-ccache-enabled'] }}
        ccache-directory: ${{ steps.cache-build.outputs['ccache-directory-path'] }}
        ccache-cache-key: ${{ steps.cache-build.outputs['ccache-cache-key'] }}
        ccache-cache-hit: ${{ steps.cache-build.outputs['ccache-cache-hit'] }}

    - name: Publish Test Results and Coverage
      uses: ./.github/actions/publish-test-results
      if: always()
      with:
        test-type: unit
        os-name: ${{ matrix.os-name }}
        build-type: ${{ matrix.build_type }}
        junit-file: junit.xml
        coverage-files: './*.gcov'
        codecov-token: ${{ secrets.CODECOV_TOKEN }}
        upload-coverage: ${{ matrix.build_type == 'debug' && 'true' || 'false' }}

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ runner.os }}-${{ matrix.build_type }}
        path: |
          junit.xml
          unit-tests-*.log
          tests.log
        retention-days: 7

  integration-tests:
    name: Integration Tests
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-15]
        include:
          - os: ubuntu-latest
            os-name: ubuntu
          - os: macos-15
            os-name: macos

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        fetch-tags: true
        submodules: true

    - name: Install dependencies with caching
      uses: ./.github/actions/install-deps
      with:
        os: ${{ matrix.os-name }}
        extra-packages: ${{ matrix.os-name == 'ubuntu' && 'lcov gcovr' || 'gcovr' }}

    - name: Cache build, dependencies, and ccache
      id: cache-build
      uses: ./.github/actions/cache-build
      with:
        cache-version: v5

    - name: Clean build directory to force reconfigure
      run: |
        rm -rf build/CMakeCache.txt build/CMakeFiles
        # Also clean test executables to ensure they're rebuilt with correct configuration
        rm -rf build/bin/test_*
        # Clean library files to prevent stale archive format issues when switching build types
        rm -rf build/lib/*.a

    - name: Build and run integration tests with coverage
      run: |
        echo "Running integration tests with coverage build..."
        # Use CMake build system with coverage
        # Use Homebrew LLVM on macOS for better standards support
        # Detect Homebrew prefix (ARM Mac uses /opt/homebrew, Intel uses /usr/local)
        if [ "${{ matrix.os-name }}" = "macos" ]; then
          if [ -d "/opt/homebrew/opt/llvm" ]; then
            HOMEBREW_PREFIX="/opt/homebrew"
          elif [ -d "/usr/local/opt/llvm" ]; then
            HOMEBREW_PREFIX="/usr/local"
          else
            echo "Error: Homebrew LLVM not found at /opt/homebrew or /usr/local"
            exit 1
          fi
          CLANG_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang"
          CLANGXX_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang++"
          echo "Using Homebrew LLVM from: ${HOMEBREW_PREFIX}/opt/llvm"
        else
          CLANG_BIN="clang"
          CLANGXX_BIN="clang++"
        fi

        FLAGS="-std=c2x --coverage"

        cmake -B build --preset github \
          -DCMAKE_C_COMPILER="${CLANG_BIN}" -DCMAKE_CXX_COMPILER="${CLANGXX_BIN}" \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="${FLAGS}"
        cmake --build build
        LOG_FILE="integration-tests-${{ matrix.os-name }}.log"
        ./tests/scripts/run_tests.sh -t integration -b coverage -J --log-file="${LOG_FILE}"
        echo "Integration tests completed successfully"
        echo "Test logs saved to: ${LOG_FILE}"

    - name: Generate coverage report
      if: always()
      uses: ./.github/actions/generate-coverage
      with:
        os-type: ${{ matrix.os-name }}

    - name: Save build caches
      if: always()
      uses: ./.github/actions/cache-build-save
      with:
        build-directory: ${{ steps.cache-build.outputs['build-directory-path'] }}
        build-cache-key: ${{ steps.cache-build.outputs['build-cache-key'] }}
        build-cache-hit: ${{ steps.cache-build.outputs['build-cache-hit'] }}
        cache-deps-enabled: ${{ steps.cache-build.outputs['cache-deps-enabled'] }}
        deps-cache-directory: ${{ steps.cache-build.outputs['deps-cache-path'] }}
        deps-cache-key: ${{ steps.cache-build.outputs['deps-cache-key'] }}
        deps-cache-hit: ${{ steps.cache-build.outputs['deps-cache-hit'] }}
        cache-ccache-enabled: ${{ steps.cache-build.outputs['cache-ccache-enabled'] }}
        ccache-directory: ${{ steps.cache-build.outputs['ccache-directory-path'] }}
        ccache-cache-key: ${{ steps.cache-build.outputs['ccache-cache-key'] }}
        ccache-cache-hit: ${{ steps.cache-build.outputs['ccache-cache-hit'] }}

    - name: Publish Test Results and Coverage
      uses: ./.github/actions/publish-test-results
      if: always()
      with:
        test-type: integration
        os-name: ${{ matrix.os-name }}
        junit-file: junit.xml
        coverage-files: './*.gcov'
        codecov-token: ${{ secrets.CODECOV_TOKEN }}
        upload-coverage: 'true'

    - name: Upload integration test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: integration-test-results-${{ runner.os }}
        path: |
          junit.xml
          integration-tests-*.log
          tests.log
        retention-days: 7

  performance-tests:
    name: Performance Tests
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-15]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        fetch-tags: true
        submodules: true

    - name: Install dependencies with caching
      uses: ./.github/actions/install-deps
      with:
        os: ${{ startsWith(matrix.os, 'ubuntu') && 'ubuntu' || 'macos' }}

    - name: Cache build, dependencies, and ccache
      id: cache-build
      uses: ./.github/actions/cache-build
      with:
        cache-version: v5

    - name: Clean build directory to force reconfigure
      run: |
        rm -rf build/CMakeCache.txt build/CMakeFiles
        # Also clean test executables to ensure they're rebuilt with correct configuration
        rm -rf build/bin/test_*
        # Clean library files to prevent stale archive format issues when switching build types
        rm -rf build/lib/*.a

    - name: Build performance tests with coverage
      run: |
        # Build performance tests with Release mode + coverage for accurate performance
        # Use Homebrew LLVM on macOS for better standards support
        # Detect Homebrew prefix (ARM Mac uses /opt/homebrew, Intel uses /usr/local)
        if [ "${{ startsWith(matrix.os, 'macos') && 'macos' || 'ubuntu' }}" = "macos" ]; then
          if [ -d "/opt/homebrew/opt/llvm" ]; then
            HOMEBREW_PREFIX="/opt/homebrew"
          elif [ -d "/usr/local/opt/llvm" ]; then
            HOMEBREW_PREFIX="/usr/local"
          else
            echo "Error: Homebrew LLVM not found at /opt/homebrew or /usr/local"
            exit 1
          fi
          CLANG_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang"
          CLANGXX_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang++"
          echo "Using Homebrew LLVM from: ${HOMEBREW_PREFIX}/opt/llvm"
        else
          CLANG_BIN="clang"
          CLANGXX_BIN="clang++"
        fi

        echo "Building performance tests with Release optimization and coverage instrumentation..."
        FLAGS="-std=c2x -O3 --coverage"

        cmake_args=(
          --preset github
          -DCMAKE_C_COMPILER="${CLANG_BIN}"
          -DCMAKE_CXX_COMPILER="${CLANGXX_BIN}"
          -DCMAKE_BUILD_TYPE=Release
          -DCMAKE_C_FLAGS="${FLAGS}"
          -DASCIICHAT_ENFORCE_STATIC_RELEASE=OFF
        )

        cmake -B build "${cmake_args[@]}"
        cmake --build build
        echo "Performance test executables built:"
        ls -la build/bin/test_performance_* 2>/dev/null || echo "No performance test executables found"

    - name: Run performance tests
      run: |
        # Run performance tests
        echo "Running performance tests..."
        LOG_FILE="performance-tests-${{ startsWith(matrix.os, 'ubuntu') && 'ubuntu' || 'macos' }}.log"
        ./tests/scripts/run_tests.sh -t performance -b release -J --log-file="${LOG_FILE}"
        echo "Performance tests completed successfully"
        echo "Test logs saved to: ${LOG_FILE}"

    - name: Save build caches
      if: always()
      uses: ./.github/actions/cache-build-save
      with:
        build-directory: ${{ steps.cache-build.outputs['build-directory-path'] }}
        build-cache-key: ${{ steps.cache-build.outputs['build-cache-key'] }}
        build-cache-hit: ${{ steps.cache-build.outputs['build-cache-hit'] }}
        cache-deps-enabled: ${{ steps.cache-build.outputs['cache-deps-enabled'] }}
        deps-cache-directory: ${{ steps.cache-build.outputs['deps-cache-path'] }}
        deps-cache-key: ${{ steps.cache-build.outputs['deps-cache-key'] }}
        deps-cache-hit: ${{ steps.cache-build.outputs['deps-cache-hit'] }}
        cache-ccache-enabled: ${{ steps.cache-build.outputs['cache-ccache-enabled'] }}
        ccache-directory: ${{ steps.cache-build.outputs['ccache-directory-path'] }}
        ccache-cache-key: ${{ steps.cache-build.outputs['ccache-cache-key'] }}
        ccache-cache-hit: ${{ steps.cache-build.outputs['ccache-cache-hit'] }}

    - name: Generate coverage report for performance tests
      if: always()
      uses: ./.github/actions/generate-coverage
      with:
        os-type: ${{ startsWith(matrix.os, 'macos') && 'macos' || 'ubuntu' }}

    - name: Publish Test Results and Coverage
      uses: ./.github/actions/publish-test-results
      if: always()
      with:
        test-type: performance
        os-name: ${{ startsWith(matrix.os, 'ubuntu') && 'ubuntu' || 'macos' }}
        junit-file: junit.xml
        coverage-files: './*.gcov'
        codecov-token: ${{ secrets.CODECOV_TOKEN }}
        upload-coverage: 'true'

    - name: Upload performance test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: performance-test-results-${{ runner.os }}
        path: |
          junit.xml
          performance-tests-*.log
          tests.log
        retention-days: 7

  memory-tests:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        fetch-tags: true
        submodules: true

    - name: Install dependencies with caching
      uses: ./.github/actions/install-deps
      with:
        os: ubuntu
        extra-packages: valgrind

    - name: Cache build, dependencies, and ccache
      id: cache-build
      uses: ./.github/actions/cache-build
      with:
        cache-version: v5

    - name: Clean build directory to force reconfigure
      run: |
        rm -rf build/CMakeCache.txt build/CMakeFiles
        # Also clean test executables to ensure they're rebuilt with correct configuration
        rm -rf build/bin/test_*
        # Clean library files to prevent stale archive format issues when switching build types
        rm -rf build/lib/*.a

    - name: Build with AddressSanitizer
      run: |
        # Use CMake build system with AddressSanitizer
        FLAGS="-std=c2x -fsanitize=address"

        cmake -B build --preset github \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="${FLAGS}"
        cmake --build build --target ascii-chat

    - name: Run memory leak detection
      run: |
        echo "Testing binary memory usage..."
        # NOTE: THese are started with "&" and run in the background with no logs.
        timeout 10s valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes \
          ./build/bin/ascii-chat server > valgrind-server.log 2>&1 &
        SERVER_PID=$!
        # Run server in the background so the command doesn't block until the process is dead so we can start the client.
        timeout 10s valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes \
          ./build/bin/ascii-chat client --test-pattern > valgrind-client.log 2>&1 &
        CLIENT_PID=$!
        # Wait for both processes - timeout exit code 124 is expected (processes ran for full duration)
        wait $SERVER_PID || true
        wait $CLIENT_PID || true

    - name: Analyze memory reports
      run: |
        echo "=== Binary Memory Analysis ==="
        if grep -q "definitely lost" valgrind-*.log; then
          echo "❌ Memory leaks detected"
          grep "definitely lost" valgrind-*.log
        else
          echo "✅ No memory leaks detected"
        fi

    - name: Save build caches
      if: always()
      uses: ./.github/actions/cache-build-save
      with:
        build-directory: ${{ steps.cache-build.outputs['build-directory-path'] }}
        build-cache-key: ${{ steps.cache-build.outputs['build-cache-key'] }}
        build-cache-hit: ${{ steps.cache-build.outputs['build-cache-hit'] }}
        cache-deps-enabled: ${{ steps.cache-build.outputs['cache-deps-enabled'] }}
        deps-cache-directory: ${{ steps.cache-build.outputs['deps-cache-path'] }}
        deps-cache-key: ${{ steps.cache-build.outputs['deps-cache-key'] }}
        deps-cache-hit: ${{ steps.cache-build.outputs['deps-cache-hit'] }}
        cache-ccache-enabled: ${{ steps.cache-build.outputs['cache-ccache-enabled'] }}
        ccache-directory: ${{ steps.cache-build.outputs['ccache-directory-path'] }}
        ccache-cache-key: ${{ steps.cache-build.outputs['ccache-cache-key'] }}
        ccache-cache-hit: ${{ steps.cache-build.outputs['ccache-cache-hit'] }}

    - name: Upload memory test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: memory-test-results
        path: |
          valgrind-*.log
        retention-days: 7

  functional-tests:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-15]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        fetch-tags: true
        submodules: true

    - name: Install dependencies with caching
      uses: ./.github/actions/install-deps
      with:
        os: ${{ startsWith(matrix.os, 'ubuntu') && 'ubuntu' || 'macos' }}
        extra-packages: ${{ startsWith(matrix.os, 'macos') && 'coreutils' || '' }}

    - name: Cache build, dependencies, and ccache
      id: cache-build
      uses: ./.github/actions/cache-build
      with:
        cache-version: v5

    - name: Clean build directory to force reconfigure
      run: |
        rm -rf build/CMakeCache.txt build/CMakeFiles
        # Also clean test executables to ensure they're rebuilt with correct configuration
        rm -rf build/bin/test_*
        # Clean library files to prevent stale archive format issues when switching build types
        rm -rf build/lib/*.a

    - name: Build project
      run: |
        # Use CMake build system
        # Use Homebrew LLVM on macOS for better standards support
        # Detect Homebrew prefix (ARM Mac uses /opt/homebrew, Intel uses /usr/local)
        if [ "${{ startsWith(matrix.os, 'macos') && 'macos' || 'ubuntu' }}" = "macos" ]; then
          if [ -d "/opt/homebrew/opt/llvm" ]; then
            HOMEBREW_PREFIX="/opt/homebrew"
          elif [ -d "/usr/local/opt/llvm" ]; then
            HOMEBREW_PREFIX="/usr/local"
          else
            echo "Error: Homebrew LLVM not found at /opt/homebrew or /usr/local"
            exit 1
          fi
          CLANG_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang"
          CLANGXX_BIN="${HOMEBREW_PREFIX}/opt/llvm/bin/clang++"
          echo "Using Homebrew LLVM from: ${HOMEBREW_PREFIX}/opt/llvm"
        else
          CLANG_BIN="clang"
          CLANGXX_BIN="clang++"
        fi

        FLAGS="-std=c2x"

        cmake -B build --preset github \
          -DCMAKE_C_COMPILER="${CLANG_BIN}" -DCMAKE_CXX_COMPILER="${CLANGXX_BIN}" \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_FLAGS="${FLAGS}" \
          -DBUILD_TESTS=OFF
        cmake --build build

    - name: Test binary help and modes
      env:
        TERM: xterm-256color
      run: |
        # Set TERM for terminal detection in CI environment
        # Test binary help
        ./build/bin/ascii-chat --help
        ./build/bin/ascii-chat server --help
        ./build/bin/ascii-chat client --help
        # Test basic server startup (short timeout)
        timeout 2s ./build/bin/ascii-chat server --log-file /tmp/server_test.log || true
        echo "Binary help and mode tests passed"

    - name: Test client capabilities
      env:
        TERM: xterm-256color
      run: |
        # Test client capabilities detection
        ./build/bin/ascii-chat client --show-capabilities
        echo "✅ Client capability detection test passed"

    - name: Save build caches
      if: always()
      uses: ./.github/actions/cache-build-save
      with:
        build-directory: ${{ steps.cache-build.outputs['build-directory-path'] }}
        build-cache-key: ${{ steps.cache-build.outputs['build-cache-key'] }}
        build-cache-hit: ${{ steps.cache-build.outputs['build-cache-hit'] }}
        cache-deps-enabled: ${{ steps.cache-build.outputs['cache-deps-enabled'] }}
        deps-cache-directory: ${{ steps.cache-build.outputs['deps-cache-path'] }}
        deps-cache-key: ${{ steps.cache-build.outputs['deps-cache-key'] }}
        deps-cache-hit: ${{ steps.cache-build.outputs['deps-cache-hit'] }}
        cache-ccache-enabled: ${{ steps.cache-build.outputs['cache-ccache-enabled'] }}
        ccache-directory: ${{ steps.cache-build.outputs['ccache-directory-path'] }}
        ccache-cache-key: ${{ steps.cache-build.outputs['ccache-cache-key'] }}
        ccache-cache-hit: ${{ steps.cache-build.outputs['ccache-cache-hit'] }}
