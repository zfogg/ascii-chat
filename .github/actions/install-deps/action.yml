name: 'Install Dependencies'
description: 'Install and cache build dependencies for ascii-chat'
inputs:
  os:
    description: 'Operating system (ubuntu, macos, or windows)'
    required: true
  extra-packages:
    description: 'Additional packages to install (space-separated)'
    required: false
    default: ''
  vcpkg-packages:
    description: 'Space-separated vcpkg packages to install for the primary triplet (Windows only)'
    required: false
    default: ''
  vcpkg-triplet:
    description: 'vcpkg triplet to use for primary packages (Windows only)'
    required: false
    default: 'x64-windows'
  vcpkg-static-packages:
    description: 'Space-separated vcpkg packages to install for the static triplet (Windows only)'
    required: false
    default: ''
  vcpkg-static-triplet:
    description: 'vcpkg triplet to use for static packages (Windows only)'
    required: false
    default: 'x64-windows-static'

runs:
  using: 'composite'
  steps:
    # =========================================================================
    # CMake 4.2.0 Installation (All platforms)
    # =========================================================================
    - name: Install CMake 4.2.0 (Ubuntu)
      if: inputs.os == 'ubuntu'
      shell: bash
      run: |
        CMAKE_VERSION="4.2.0"
        CMAKE_URL="https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-linux-x86_64.tar.gz"
        CMAKE_INSTALL_DIR="/opt/cmake-${CMAKE_VERSION}"

        echo "Installing CMake ${CMAKE_VERSION} from official release..."
        curl -fsSL "$CMAKE_URL" -o /tmp/cmake.tar.gz
        sudo mkdir -p "$CMAKE_INSTALL_DIR"
        sudo tar -xzf /tmp/cmake.tar.gz -C "$CMAKE_INSTALL_DIR" --strip-components=1
        rm /tmp/cmake.tar.gz

        # Add to PATH (prepend so it takes priority)
        echo "${CMAKE_INSTALL_DIR}/bin" >> $GITHUB_PATH
        echo "Installed CMake ${CMAKE_VERSION} to ${CMAKE_INSTALL_DIR}"
        "${CMAKE_INSTALL_DIR}/bin/cmake" --version

    - name: Install CMake 4.2.0 (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        CMAKE_VERSION="4.2.0"
        CMAKE_URL="https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-macos-universal.tar.gz"
        CMAKE_INSTALL_DIR="/opt/cmake-${CMAKE_VERSION}"

        echo "Installing CMake ${CMAKE_VERSION} from official release..."
        curl -fsSL "$CMAKE_URL" -o /tmp/cmake.tar.gz
        sudo mkdir -p "$CMAKE_INSTALL_DIR"
        sudo tar -xzf /tmp/cmake.tar.gz -C "$CMAKE_INSTALL_DIR" --strip-components=1
        rm /tmp/cmake.tar.gz

        # The macOS bundle has CMake.app/Contents/bin/cmake
        if [ -d "${CMAKE_INSTALL_DIR}/CMake.app/Contents/bin" ]; then
          CMAKE_BIN_DIR="${CMAKE_INSTALL_DIR}/CMake.app/Contents/bin"
        else
          CMAKE_BIN_DIR="${CMAKE_INSTALL_DIR}/bin"
        fi

        # Add to PATH (prepend so it takes priority)
        echo "${CMAKE_BIN_DIR}" >> $GITHUB_PATH
        echo "Installed CMake ${CMAKE_VERSION} to ${CMAKE_INSTALL_DIR}"
        "${CMAKE_BIN_DIR}/cmake" --version

    - name: Install CMake 4.2.0 (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $CMAKE_VERSION = "4.2.0"
        $CMAKE_URL = "https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-windows-x86_64.zip"
        $CMAKE_INSTALL_DIR = "C:\cmake-${CMAKE_VERSION}"

        Write-Host "Installing CMake ${CMAKE_VERSION} from official release..."
        $tempZip = "$env:TEMP\cmake.zip"
        Invoke-WebRequest -Uri $CMAKE_URL -OutFile $tempZip -UseBasicParsing

        # Extract to install directory
        if (Test-Path $CMAKE_INSTALL_DIR) {
          Remove-Item -Recurse -Force $CMAKE_INSTALL_DIR
        }
        Expand-Archive -Path $tempZip -DestinationPath "C:\"
        Rename-Item -Path "C:\cmake-${CMAKE_VERSION}-windows-x86_64" -NewName "cmake-${CMAKE_VERSION}"
        Remove-Item $tempZip

        # Add to PATH (prepend so it takes priority)
        $CMAKE_BIN_DIR = "${CMAKE_INSTALL_DIR}\bin"
        Add-Content -Path $env:GITHUB_PATH -Value $CMAKE_BIN_DIR
        Write-Host "Installed CMake ${CMAKE_VERSION} to ${CMAKE_INSTALL_DIR}"
        & "${CMAKE_BIN_DIR}\cmake.exe" --version

    # =========================================================================
    # Dependency Caches
    # =========================================================================
    - name: Restore CMake dependency cache (All platforms)
      id: cmake-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          .deps-cache
          deps/bearssl/build
        key: ${{ runner.os }}-cmake-deps-v3-${{ hashFiles('cmake/dependencies/**') }}

    - name: Clean stale dependency cache (if cache not hit)
      if: steps.cmake-cache.outputs.cache-hit != 'true'
      shell: bash
      run: |
        # Remove .deps-cache to avoid stale artifacts from previous builds (e.g., musl artifacts mixing with glibc)
        if [ -d ".deps-cache" ]; then
          echo "Cache not hit - cleaning .deps-cache to remove stale artifacts..."
          rm -rf .deps-cache
        fi
        # Also clean deps/bearssl/build if it exists
        if [ -d "deps/bearssl/build" ]; then
          rm -rf deps/bearssl/build
        fi

    - name: Restore Homebrew cache (macOS)
      if: inputs.os == 'macos'
      id: homebrew-cache
      uses: actions/cache/restore@v4
      with:
        # NOTE: GitHub-hosted macOS runners already populate /opt/homebrew with
        # a Homebrew installation. Restoring cached copies of /opt/homebrew/*
        # causes tar extractions to fail when a package (e.g. pydantic-core) is
        # already present, so only cache the download artifacts.
        path: |
          ~/Library/Caches/Homebrew
        key: ${{ runner.os }}-homebrew-v2-${{ inputs.extra-packages }}
        restore-keys: |
          ${{ runner.os }}-homebrew-v2-
          ${{ runner.os }}-homebrew-

    - name: Install Homebrew packages (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        # Update Homebrew
        brew update

        # Install packages
        PACKAGES="pkg-config llvm ccache make ninja zstd portaudio libsodium criterion coreutils ${{ inputs.extra-packages }}"

        echo "Installing Homebrew packages: $PACKAGES"
        for pkg in $PACKAGES; do
          if brew list --formula | grep -q "^${pkg}\$"; then
            echo "✓ $pkg already installed"
          else
            echo "Installing $pkg..."
            brew install "$pkg"
          fi
        done

        # Clean up to reduce cache size
        brew cleanup

    - name: Compute base packages hash (Ubuntu)
      if: inputs.os == 'ubuntu'
      id: base-packages-hash
      shell: bash
      run: |
        # Define base packages list once - this is the single source of truth
        base_packages="clang libclang-dev llvm-dev ccache ninja-build zlib1g-dev libzstd-dev libcurl4-openssl-dev zstd portaudio19-dev libjack-jackd2-0 libjack-jackd2-dev libasound2-dev libboxfort-dev libsodium-dev libcriterion-dev libgit2-dev libnanomsg-dev libnanomsg5 libprotobuf-c-dev libprotobuf-c1 libprotobuf-dev libssl-dev libssh2-1-dev libhttp-parser-dev libpcre2-dev libpcre2-8-0 libkrb5-dev krb5-multidev libgssapi-krb5-2 libkrb5-3 libk5crypto3 libcom-err2 libnanopb-dev pkg-config libxml2-utils python3-pip llvm musl-tools musl-dev"
        # Compute SHA256 hash of base packages (first 8 chars for cache key)
        hash=$(echo -n "$base_packages" | sha256sum | cut -c1-8)
        echo "hash=$hash" >> $GITHUB_OUTPUT
        echo "packages=$base_packages" >> $GITHUB_OUTPUT
        echo "Base packages hash: $hash"

    - name: Restore APT cache (Ubuntu)
      if: inputs.os == 'ubuntu'
      id: apt-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          /var/cache/apt/archives
          /var/lib/apt/lists
        key: ${{ runner.os }}-apt-v2-${{ steps.base-packages-hash.outputs.hash }}-${{ inputs.extra-packages }}
        restore-keys: |
          ${{ runner.os }}-apt-v2-${{ steps.base-packages-hash.outputs.hash }}-
          ${{ runner.os }}-apt-v2-

    - name: Install APT packages (Ubuntu)
      if: inputs.os == 'ubuntu'
      shell: bash
      run: |
        set -euo pipefail

        # Use base packages from the hash computation step (single source of truth)
        base_packages="${{ steps.base-packages-hash.outputs.packages }}"
        extra="${{ inputs.extra-packages }}"
        tools="$base_packages"
        if [ -n "$extra" ]; then
          tools="$tools $extra"
        fi

        # Update package lists
        sudo apt-get update

        # Install packages (cache will speed up downloads)
        echo "Installing APT packages: $tools"
        sudo apt-get install -y --no-install-recommends $tools

    - name: Restore vcpkg packages (Windows)
      if: inputs.os == 'windows' && env.VCPKG_ROOT != ''
      id: vcpkg-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/installed
          ${{ env.VCPKG_ROOT }}/packages
          ${{ env.VCPKG_ROOT }}/buildtrees
        key: ${{ runner.os }}-vcpkg-v1-${{ inputs.vcpkg-packages }}-${{ inputs.vcpkg-static-packages }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-v1-

    - name: Set CSTD env var (POSIX)
      if: inputs.os != 'windows'
      shell: bash
      run: |
        # Setup CSTD
        export CSTD=c2x
        echo "CSTD=$CSTD" >> $GITHUB_ENV
        echo "Set CSTD to $CSTD"

    - name: Set CSTD env var (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $value = 'c2x'
        Add-Content -Path $env:GITHUB_ENV -Value "CSTD=$value"
        Write-Host "Set CSTD to $value"

    - name: Install Windows build tools
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        function Ensure-Scoop {
          if (Get-Command scoop -ErrorAction SilentlyContinue) {
            Write-Host "Scoop already installed"
            return
          }

          Write-Host "Scoop not found. Installing scoop..."
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
          Invoke-RestMethod get.scoop.sh | Invoke-Expression
        }

        function Ensure-ScoopBucket {
          param(
            [string]$Bucket
          )

          if (-not (scoop bucket list | Select-String -SimpleMatch $Bucket)) {
            Write-Host "Adding scoop bucket: $Bucket"
            scoop bucket add $Bucket | Out-Null
          }
        }

        function Install-ScoopPackage {
          param(
            [string]$Package
          )

          if ([string]::IsNullOrWhiteSpace($Package)) {
            return
          }

          if (scoop list | Select-String -SimpleMatch "^$Package\s") {
            Write-Host "✓ $Package already installed via scoop"
          }
          else {
            Write-Host "Installing scoop package: $Package"
            scoop install $Package --global
          }
        }

        Ensure-Scoop
        Ensure-ScoopBucket -Bucket 'main'
        Ensure-ScoopBucket -Bucket 'extras'

        $basePackages = @('git', '7zip', 'ninja', 'llvm', 'ccache')
        $extra = @()
        if (-not [string]::IsNullOrWhiteSpace('${{ inputs.extra-packages }}')) {
          $extra = '${{ inputs.extra-packages }}'.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
        }
        $packages = $basePackages + $extra

        foreach ($pkg in $packages) {
          Install-ScoopPackage -Package $pkg
        }

        $scoopShims = Join-Path $env:USERPROFILE 'scoop\shims'
        if (Test-Path $scoopShims) {
          Write-Host "Adding scoop shims to PATH"
          Add-Content -Path $env:GITHUB_PATH -Value $scoopShims
        } else {
          Write-Host "Scoop shims not found at $scoopShims"
          exit 1
        }

        $llvmPath = 'C:\Program Files\LLVM\bin'
        if (Test-Path $llvmPath) {
          Write-Host "Adding LLVM to PATH"
          Add-Content -Path $env:GITHUB_PATH -Value $llvmPath
        } else {
          Write-Host "LLVM not found at $llvmPath"
          exit 1
        }

    - name: Set up build environment (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        BREW_PREFIX="$(brew --prefix)"
        echo "Detected Homebrew prefix: ${BREW_PREFIX}"

        # NOTE: `brew info make` says "make" is installed as "gmake", but they give us gnubin
        if [ -d "${BREW_PREFIX}/opt/make/libexec/gnubin" ]; then
          export PATH="${BREW_PREFIX}/opt/make/libexec/gnubin:$PATH"
        fi
        if [ -d "${BREW_PREFIX}/opt/llvm/bin" ]; then
          export PATH="${BREW_PREFIX}/opt/llvm/bin:$PATH"
        fi

        export PKG_CONFIG_LIBS="portaudio-2.0 criterion libzstd libsodium"
        export PKG_CONFIG_PATH="${BREW_PREFIX}/lib/pkgconfig:${BREW_PREFIX}/share/pkgconfig"
        export CPPFLAGS="-I${BREW_PREFIX}/include"
        export LDFLAGS="-L${BREW_PREFIX}/lib"

        if [ -d "${BREW_PREFIX}/opt/llvm/lib/unwind" ]; then
          export LDFLAGS="$LDFLAGS -L${BREW_PREFIX}/opt/llvm/lib/unwind -lunwind"
        fi
        if [ -d "${BREW_PREFIX}/opt/llvm/lib/c++" ]; then
          export LDFLAGS="$LDFLAGS -L${BREW_PREFIX}/opt/llvm/lib/c++"
        fi

        map_pkg_to_formula() {
          case "$1" in
            portaudio-2.0) echo "portaudio" ;;
            libzstd) echo "zstd" ;;
            libsodium) echo "libsodium" ;;
            criterion) echo "criterion" ;;
            *) echo "$1" ;;
          esac
        }

        append_pkgconfig_path_if_exists() {
          local dir="$1"
          if [ -d "$dir" ]; then
            if [[ ":$PKG_CONFIG_PATH:" != *":$dir:"* ]]; then
              PKG_CONFIG_PATH="${PKG_CONFIG_PATH}:$dir"
            fi
          fi
        }

        for lib in $PKG_CONFIG_LIBS; do
          formula="$(map_pkg_to_formula "$lib")"
          if prefix="$(brew --prefix "$formula" 2>/dev/null)"; then
            append_pkgconfig_path_if_exists "${prefix}/lib/pkgconfig"
            append_pkgconfig_path_if_exists "${prefix}/share/pkgconfig"
          fi
        done

        # Set up PATH
        echo "PATH=$PATH" >> $GITHUB_ENV

        # Set up pkg-config path for Homebrew packages (always needed)
        echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
        echo "CPPFLAGS=$CPPFLAGS" >> $GITHUB_ENV
        echo "LDFLAGS=$LDFLAGS" >> $GITHUB_ENV
        echo "PKG_CONFIG_LIBS=$PKG_CONFIG_LIBS" >> $GITHUB_ENV

        # Verify they will be set for subsequent steps
        echo "Set PKG_CONFIG_PATH to $PKG_CONFIG_PATH"
        echo "Set CPPFLAGS to $CPPFLAGS"
        echo "Set LDFLAGS to $LDFLAGS"

        # Debug: Check if pkg-config can find portaudio immediately after setting env vars
        echo "Debug: Testing pkg-config with PKG_CONFIG_PATH and PKG_CONFIG_LIBS..."
        pkg-config --libs --cflags "$PKG_CONFIG_LIBS"

        # Debug: Check if .pc files exist
        echo "Debug: Checking .pc files existence..."
        for lib in $PKG_CONFIG_LIBS; do
          if ! pkg-config --exists "$lib"; then
            echo "ERROR: pkg-config could not locate $lib"
            echo "       PKG_CONFIG_PATH=$PKG_CONFIG_PATH"
            echo "       pkg-config --variable=pc_path pkg-config:"
            pkg-config --variable=pc_path pkg-config || true
            echo "       Contents of $(brew --prefix "$(map_pkg_to_formula "$lib")" 2>/dev/null)/lib/pkgconfig:"
            ls -la "$(brew --prefix "$(map_pkg_to_formula "$lib")" 2>/dev/null)/lib/pkgconfig" || true
            exit 1
          fi
        done

        # Configure clang to work without Command Line Tools
        # This allows Homebrew LLVM to find the macOS SDK
        mkdir -p ~/.config/clang

        # Get Darwin version for config filename
        DARWIN_VERSION=$(uname -r | cut -d. -f1)
        SDK_PATH=$(xcrun --show-sdk-path 2>/dev/null || echo "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk")

        # Create x86_64 config
        cat > ~/.config/clang/x86_64-apple-darwin${DARWIN_VERSION}.cfg << EOF
        # Clang configuration for x86_64 macOS
        -isysroot ${SDK_PATH}
        -isystem ${SDK_PATH}/usr/include
        -stdlib=libc++
        -resource-dir ${BREW_PREFIX}/opt/llvm/lib/clang/21
        EOF

        # Create ARM64 config
        cat > ~/.config/clang/arm64-apple-darwin${DARWIN_VERSION}.cfg << EOF
        # Clang configuration for ARM64 macOS
        -isysroot ${SDK_PATH}
        -isystem ${SDK_PATH}/usr/include
        -stdlib=libc++
        -resource-dir ${BREW_PREFIX}/opt/llvm/lib/clang/21
        EOF

        echo "Created clang config files for darwin${DARWIN_VERSION}"
        ls -la ~/.config/clang/

    - name: Install vcpkg packages (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        if (-not $env:VCPKG_ROOT) {
          Write-Host "VCPKG_ROOT is not set. Please run lukka/run-vcpkg before install-deps." -ForegroundColor Red
          exit 1
        }

        function Install-VcpkgPackages {
          param(
            [string]$PackageList,
            [string]$Triplet
          )

          if ([string]::IsNullOrWhiteSpace($PackageList)) {
            return
          }

          $packages = $PackageList.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
          foreach ($pkg in $packages) {
            Write-Host "Installing vcpkg package: $pkg:$Triplet"
            vcpkg install "$pkg`:$Triplet"
          }
        }

        Install-VcpkgPackages -PackageList '${{ inputs.vcpkg-packages }}' -Triplet '${{ inputs.vcpkg-triplet }}'
        Install-VcpkgPackages -PackageList '${{ inputs.vcpkg-static-packages }}' -Triplet '${{ inputs.vcpkg-static-triplet }}'

    - name: Save CMake dependency cache (All platforms)
      if: always() && steps.cmake-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          .deps-cache
          deps/bearssl/build
        key: ${{ runner.os }}-cmake-deps-v3-${{ hashFiles('cmake/dependencies/**') }}

    - name: Save Homebrew cache (macOS)
      if: always() && inputs.os == 'macos' && steps.homebrew-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ~/Library/Caches/Homebrew
        key: ${{ runner.os }}-homebrew-v2-${{ inputs.extra-packages }}

    - name: Save vcpkg packages (Windows)
      if: always() && inputs.os == 'windows' && env.VCPKG_ROOT != '' && steps.vcpkg-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/installed
          ${{ env.VCPKG_ROOT }}/packages
          ${{ env.VCPKG_ROOT }}/buildtrees
        key: ${{ runner.os }}-vcpkg-v1-${{ inputs.vcpkg-packages }}-${{ inputs.vcpkg-static-packages }}

    - name: Save APT cache (Ubuntu)
      if: always() && inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          /var/cache/apt/archives
          /var/lib/apt/lists
        key: ${{ runner.os }}-apt-v2-${{ steps.base-packages-hash.outputs.hash }}-${{ inputs.extra-packages }}
