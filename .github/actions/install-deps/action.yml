name: 'Install Dependencies'
description: 'Install and cache build dependencies for ascii-chat'
inputs:
  os:
    description: 'Operating system (ubuntu, macos, or windows)'
    required: true
  extra-packages:
    description: 'Additional packages to install (space-separated)'
    required: false
    default: ''
  vcpkg-packages:
    description: 'Space-separated vcpkg packages to install for the primary triplet (Windows only)'
    required: false
    default: ''
  vcpkg-triplet:
    description: 'vcpkg triplet to use for primary packages (Windows only)'
    required: false
    default: 'x64-windows'
  vcpkg-static-packages:
    description: 'Space-separated vcpkg packages to install for the static triplet (Windows only)'
    required: false
    default: ''
  vcpkg-static-triplet:
    description: 'vcpkg triplet to use for static packages (Windows only)'
    required: false
    default: 'x64-windows-static'

runs:
  using: 'composite'
  steps:
    # =========================================================================
    # CMake 4.2.0 Installation (macOS and Windows only)
    # =========================================================================
    # NOTE: Ubuntu uses scripts/install-deps.sh which installs CMake via Kitware APT repo

    # NOTE: macOS CMake is installed via Homebrew in install-deps.sh

    - name: Install CMake 4.2.0 (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $CMAKE_VERSION = "4.2.0"
        $CMAKE_URL = "https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-windows-x86_64.zip"
        $CMAKE_INSTALL_DIR = "C:\cmake-${CMAKE_VERSION}"

        Write-Host "Installing CMake ${CMAKE_VERSION} from official release..."
        $tempZip = "$env:TEMP\cmake.zip"
        Invoke-WebRequest -Uri $CMAKE_URL -OutFile $tempZip -UseBasicParsing

        # Extract to install directory
        if (Test-Path $CMAKE_INSTALL_DIR) {
          Remove-Item -Recurse -Force $CMAKE_INSTALL_DIR
        }
        Expand-Archive -Path $tempZip -DestinationPath "C:\"
        Rename-Item -Path "C:\cmake-${CMAKE_VERSION}-windows-x86_64" -NewName "cmake-${CMAKE_VERSION}"
        Remove-Item $tempZip

        # Add to PATH (prepend so it takes priority)
        $CMAKE_BIN_DIR = "${CMAKE_INSTALL_DIR}\bin"
        Add-Content -Path $env:GITHUB_PATH -Value $CMAKE_BIN_DIR
        Write-Host "Installed CMake ${CMAKE_VERSION} to ${CMAKE_INSTALL_DIR}"
        & "${CMAKE_BIN_DIR}\cmake.exe" --version

    # =========================================================================
    # Dependency Caches
    # =========================================================================
    - name: Restore CMake dependency cache (All platforms)
      id: cmake-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          .deps-cache
          deps/bearssl/build
        # Include runner.arch to separate x86_64 and arm64 caches on macOS
        key: ${{ runner.os }}-${{ runner.arch }}-cmake-deps-v6-${{ hashFiles('cmake/dependencies/**') }}

    - name: Compute install-deps.sh hash (macOS)
      if: inputs.os == 'macos'
      id: install-deps-sh-hash-macos
      shell: bash
      run: |
        # Use scripts/install-deps.sh as the single source of truth for package installation
        # Hash the install-deps.sh script to invalidate cache when dependencies change
        hash=$(shasum -a 256 scripts/install-deps.sh | cut -c1-8)
        echo "hash=$hash" >> $GITHUB_OUTPUT
        echo "install-deps.sh hash: $hash"

    - name: Restore Homebrew cache (macOS)
      if: inputs.os == 'macos'
      id: homebrew-cache
      uses: actions/cache/restore@v4
      with:
        # NOTE: GitHub-hosted macOS runners already populate /opt/homebrew with
        # a Homebrew installation. Restoring cached copies of /opt/homebrew/*
        # causes tar extractions to fail when a package (e.g. pydantic-core) is
        # already present, so only cache the download artifacts.
        path: |
          ~/Library/Caches/Homebrew
        key: ${{ runner.os }}-homebrew-v3-${{ steps.install-deps-sh-hash-macos.outputs.hash }}-${{ inputs.extra-packages }}
        restore-keys: |
          ${{ runner.os }}-homebrew-v3-${{ steps.install-deps-sh-hash-macos.outputs.hash }}-
          ${{ runner.os }}-homebrew-v3-

    - name: Install dependencies via scripts/install-deps.sh (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        set -euo pipefail

        echo "Running scripts/install-deps.sh to install build dependencies..."
        # install-deps.sh handles all Homebrew package installation
        bash scripts/install-deps.sh

        # Install any extra packages requested by the workflow
        extra="${{ inputs.extra-packages }}"
        if [ -n "$extra" ]; then
          echo "Installing additional packages: $extra"
          brew install $extra
        fi

        # Clean up to reduce cache size
        brew cleanup

    - name: Compute install-deps.sh hash (Ubuntu)
      if: inputs.os == 'ubuntu'
      id: install-deps-sh-hash
      shell: bash
      run: |
        # Use scripts/install-deps.sh as the single source of truth for package installation
        # Hash the install-deps.sh script to invalidate cache when dependencies change
        hash=$(sha256sum scripts/install-deps.sh | cut -c1-8)
        echo "hash=$hash" >> $GITHUB_OUTPUT
        echo "install-deps.sh hash: $hash"

    - name: Restore APT cache (Ubuntu)
      if: inputs.os == 'ubuntu'
      id: apt-cache
      uses: actions/cache/restore@v4
      with:
        # Cache to workspace directory to avoid permission issues
        path: .apt-cache
        key: ${{ runner.os }}-apt-v5-${{ steps.install-deps-sh-hash.outputs.hash }}-${{ inputs.extra-packages }}
        restore-keys: |
          ${{ runner.os }}-apt-v5-${{ steps.install-deps-sh-hash.outputs.hash }}-
          ${{ runner.os }}-apt-v5-

    - name: Restore APT cache to system (Ubuntu)
      if: inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit == 'true'
      shell: bash
      run: |
        if [ -d ".apt-cache" ] && [ "$(ls -A .apt-cache 2>/dev/null)" ]; then
          echo "Restoring $(ls .apt-cache/*.deb 2>/dev/null | wc -l) cached .deb files..."
          sudo cp .apt-cache/*.deb /var/cache/apt/archives/ 2>/dev/null || true
        fi

    - name: Disable problematic Microsoft APT repos (Ubuntu)
      if: inputs.os == 'ubuntu'
      shell: bash
      run: |
        # Microsoft's Azure CLI repos sometimes return 403 errors on GitHub Actions
        # Disable them since we don't need Azure CLI for building ascii-chat
        for repo in /etc/apt/sources.list.d/microsoft*.list /etc/apt/sources.list.d/azure*.list; do
          if [[ -f "$repo" ]]; then
            echo "Disabling problematic repo: $repo"
            sudo mv "$repo" "$repo.disabled" || true
          fi
        done

    - name: Install dependencies via scripts/install-deps.sh (Ubuntu)
      if: inputs.os == 'ubuntu'
      shell: bash
      run: |
        set -euo pipefail

        echo "Running scripts/install-deps.sh to install build dependencies..."
        # install-deps.sh handles:
        # - CMake 4.2.0 installation via Kitware APT repository
        # - All build dependencies (clang-21, llvm-21-dev, etc.)
        # - LLVM 21 update-alternatives configuration
        # --dangerously-delete-conflicts: GitHub runners have pre-installed binaries
        # in /usr/bin that shadow update-alternatives. The flag allows deletion
        # only when CI=true (set by GitHub Actions).
        bash scripts/install-deps.sh --dangerously-delete-conflicts

        # Install any extra packages requested by the workflow
        extra="${{ inputs.extra-packages }}"
        if [ -n "$extra" ]; then
          echo "Installing additional packages: $extra"
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends $extra
        fi

    - name: Restore vcpkg packages (Windows)
      if: inputs.os == 'windows' && env.VCPKG_ROOT != ''
      id: vcpkg-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/installed
          ${{ env.VCPKG_ROOT }}/packages
          ${{ env.VCPKG_ROOT }}/buildtrees
        key: ${{ runner.os }}-vcpkg-v1-${{ inputs.vcpkg-packages }}-${{ inputs.vcpkg-static-packages }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-v1-

    - name: Set CSTD env var (POSIX)
      if: inputs.os != 'windows'
      shell: bash
      run: |
        # Setup CSTD
        export CSTD=c2x
        echo "CSTD=$CSTD" >> $GITHUB_ENV
        echo "Set CSTD to $CSTD"

    - name: Set CSTD env var (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $value = 'c2x'
        Add-Content -Path $env:GITHUB_ENV -Value "CSTD=$value"
        Write-Host "Set CSTD to $value"

    - name: Install Windows build tools (scoop)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        function Ensure-Scoop {
          if (Get-Command scoop -ErrorAction SilentlyContinue) {
            Write-Host "Scoop already installed"
            return
          }

          Write-Host "Scoop not found. Installing scoop..."
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
          Invoke-RestMethod get.scoop.sh | Invoke-Expression
        }

        function Ensure-ScoopBucket {
          param(
            [string]$Bucket
          )

          # Use try/catch for robustness - scoop bucket add is idempotent
          try {
            $buckets = scoop bucket list 2>$null
            if ($buckets -notmatch [regex]::Escape($Bucket)) {
              Write-Host "Adding scoop bucket: $Bucket"
              scoop bucket add $Bucket 2>$null | Out-Null
            }
          } catch {
            Write-Host "Adding scoop bucket: $Bucket (first time)"
            scoop bucket add $Bucket 2>$null | Out-Null
          }
        }

        function Install-ScoopPackage {
          param(
            [string]$Package
          )

          if ([string]::IsNullOrWhiteSpace($Package)) {
            return
          }

          # Check if package is installed using string matching
          $installed = scoop list 2>$null | Out-String
          if ($installed -match "(?m)^\s*$([regex]::Escape($Package))\s") {
            Write-Host "Package already installed via scoop: $Package"
          }
          else {
            Write-Host "Installing scoop package: $Package"
            scoop install $Package --global
          }
        }

        Ensure-Scoop
        Ensure-ScoopBucket -Bucket 'main'
        Ensure-ScoopBucket -Bucket 'extras'

        # NOTE: LLVM is installed separately from vovkos/llvm-package-windows
        # because scoop/choco/winget LLVM packages don't include dev libraries
        $basePackages = @('git', '7zip', 'ninja', 'ccache')
        $extra = @()
        if (-not [string]::IsNullOrWhiteSpace('${{ inputs.extra-packages }}')) {
          $extra = '${{ inputs.extra-packages }}'.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
        }
        $packages = $basePackages + $extra

        foreach ($pkg in $packages) {
          Install-ScoopPackage -Package $pkg
        }

        # Add scoop shims to PATH (both user and global locations)
        # Global installs (--global) go to C:\ProgramData\scoop
        $scoopShimsUser = Join-Path $env:USERPROFILE 'scoop\shims'
        $scoopShimsGlobal = 'C:\ProgramData\scoop\shims'
        $foundShims = $false
        foreach ($shimsPath in @($scoopShimsGlobal, $scoopShimsUser)) {
          if (Test-Path $shimsPath) {
            Write-Host "Adding scoop shims to PATH: $shimsPath"
            Add-Content -Path $env:GITHUB_PATH -Value $shimsPath
            $foundShims = $true
          }
        }
        if (-not $foundShims) {
          Write-Host "No scoop shims found"
          exit 1
        }

    # =========================================================================
    # LLVM with Development Libraries (Windows)
    # =========================================================================
    # The official LLVM Windows installer and scoop/choco/winget packages only
    # include compiler binaries (clang.exe), NOT the development libraries
    # (LLVMSupport.lib, clangTooling.lib, etc.) needed to build the defer tool.
    # We use vovkos/llvm-package-windows which provides full LLVM dev libraries.
    - name: Install LLVM with dev libraries (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        $LLVM_VERSION = "20.1.8"
        $LLVM_INSTALL_DIR = "C:\LLVM"
        $LLVM_ARCHIVE = "clang-${LLVM_VERSION}-windows-amd64-msvc17-msvcrt.7z"
        $LLVM_URL = "https://github.com/vovkos/llvm-package-windows/releases/download/clang-${LLVM_VERSION}/${LLVM_ARCHIVE}"

        # Check if LLVM with dev libraries is already installed
        if (Test-Path "${LLVM_INSTALL_DIR}\lib\LLVMSupport.lib") {
          Write-Host "LLVM with dev libraries already installed at ${LLVM_INSTALL_DIR}"
        } else {
          Write-Host "Downloading LLVM ${LLVM_VERSION} with dev libraries from vovkos/llvm-package-windows..."
          $tempArchive = "$env:TEMP\${LLVM_ARCHIVE}"

          # Download the archive
          Invoke-WebRequest -Uri $LLVM_URL -OutFile $tempArchive -UseBasicParsing
          Write-Host "Downloaded to ${tempArchive}"

          # Extract to install directory
          if (Test-Path $LLVM_INSTALL_DIR) {
            Write-Host "Removing existing LLVM installation..."
            Remove-Item -Recurse -Force $LLVM_INSTALL_DIR
          }

          Write-Host "Extracting LLVM to ${LLVM_INSTALL_DIR}..."
          # 7zip is installed via scoop in the previous step
          7z x $tempArchive -o"C:\" -y | Out-Null

          # The archive extracts to clang-VERSION-windows-amd64-msvc17-msvcrt, rename it
          $extractedDir = "C:\clang-${LLVM_VERSION}-windows-amd64-msvc17-msvcrt"
          if (Test-Path $extractedDir) {
            Rename-Item -Path $extractedDir -NewName "LLVM"
          }

          Remove-Item $tempArchive -Force

          # Verify installation - check for clangTooling.lib which is what defer tool needs
          # Also check for LLVMSupport.lib as a secondary indicator
          $hasClangTooling = Test-Path "${LLVM_INSTALL_DIR}\lib\clangTooling.lib"
          $hasLLVMSupport = Test-Path "${LLVM_INSTALL_DIR}\lib\LLVMSupport.lib"

          Write-Host "Checking LLVM installation..."
          Write-Host "  clangTooling.lib: $hasClangTooling"
          Write-Host "  LLVMSupport.lib: $hasLLVMSupport"

          if ($hasClangTooling) {
            Write-Host "LLVM ${LLVM_VERSION} with dev libraries installed successfully"
            # List some key libs for verification
            Write-Host "Key libraries found:"
            Get-ChildItem "${LLVM_INSTALL_DIR}\lib\*.lib" | Where-Object { $_.Name -match "^(clangTooling|clangFrontend|clangBasic|LLVMSupport)" } | ForEach-Object { Write-Host "  $($_.Name)" }
          } else {
            Write-Host "ERROR: clangTooling.lib not found after installation" -ForegroundColor Red
            Write-Host "Contents of ${LLVM_INSTALL_DIR}\lib:"
            Get-ChildItem "${LLVM_INSTALL_DIR}\lib\*.lib" -ErrorAction SilentlyContinue | Select-Object -First 30 | ForEach-Object { Write-Host "  $($_.Name)" }
            exit 1
          }
        }

        # Add LLVM to PATH (prepend by using GITHUB_PATH - entries are prepended)
        $llvmBinPath = "${LLVM_INSTALL_DIR}\bin"
        Write-Host "Adding LLVM to PATH: ${llvmBinPath}"
        Add-Content -Path $env:GITHUB_PATH -Value $llvmBinPath

        # Set CC and CXX to full paths to our vovkos LLVM
        # This overrides the workflow-level CC=clang, CXX=clang++ which would resolve to the pre-installed LLVM
        Write-Host "Setting CC=${llvmBinPath}\clang.exe"
        Write-Host "Setting CXX=${llvmBinPath}\clang++.exe"
        Add-Content -Path $env:GITHUB_ENV -Value "CC=${llvmBinPath}\clang.exe"
        Add-Content -Path $env:GITHUB_ENV -Value "CXX=${llvmBinPath}\clang++.exe"

        # Verify clang is accessible
        & "${llvmBinPath}\clang.exe" --version

    - name: Set up build environment (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        BREW_PREFIX="$(brew --prefix)"
        echo "Detected Homebrew prefix: ${BREW_PREFIX}"

        # NOTE: `brew info make` says "make" is installed as "gmake", but they give us gnubin
        if [ -d "${BREW_PREFIX}/opt/make/libexec/gnubin" ]; then
          export PATH="${BREW_PREFIX}/opt/make/libexec/gnubin:$PATH"
        fi
        if [ -d "${BREW_PREFIX}/opt/llvm/bin" ]; then
          export PATH="${BREW_PREFIX}/opt/llvm/bin:$PATH"
        fi

        export PKG_CONFIG_LIBS="portaudio-2.0 criterion libzstd libsodium"
        export PKG_CONFIG_PATH="${BREW_PREFIX}/lib/pkgconfig:${BREW_PREFIX}/share/pkgconfig"
        export CPPFLAGS="-I${BREW_PREFIX}/include"
        export LDFLAGS="-L${BREW_PREFIX}/lib"

        if [ -d "${BREW_PREFIX}/opt/llvm/lib/unwind" ]; then
          export LDFLAGS="$LDFLAGS -L${BREW_PREFIX}/opt/llvm/lib/unwind -lunwind"
        fi
        if [ -d "${BREW_PREFIX}/opt/llvm/lib/c++" ]; then
          export LDFLAGS="$LDFLAGS -L${BREW_PREFIX}/opt/llvm/lib/c++"
        fi

        map_pkg_to_formula() {
          case "$1" in
            portaudio-2.0) echo "portaudio" ;;
            libzstd) echo "zstd" ;;
            libsodium) echo "libsodium" ;;
            criterion) echo "criterion" ;;
            *) echo "$1" ;;
          esac
        }

        append_pkgconfig_path_if_exists() {
          local dir="$1"
          if [ -d "$dir" ]; then
            if [[ ":$PKG_CONFIG_PATH:" != *":$dir:"* ]]; then
              PKG_CONFIG_PATH="${PKG_CONFIG_PATH}:$dir"
            fi
          fi
        }

        for lib in $PKG_CONFIG_LIBS; do
          formula="$(map_pkg_to_formula "$lib")"
          if prefix="$(brew --prefix "$formula" 2>/dev/null)"; then
            append_pkgconfig_path_if_exists "${prefix}/lib/pkgconfig"
            append_pkgconfig_path_if_exists "${prefix}/share/pkgconfig"
          fi
        done

        # Set up PATH
        echo "PATH=$PATH" >> $GITHUB_ENV

        # Set up pkg-config path for Homebrew packages (always needed)
        echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
        echo "CPPFLAGS=$CPPFLAGS" >> $GITHUB_ENV
        echo "LDFLAGS=$LDFLAGS" >> $GITHUB_ENV
        echo "PKG_CONFIG_LIBS=$PKG_CONFIG_LIBS" >> $GITHUB_ENV

        # Verify they will be set for subsequent steps
        echo "Set PKG_CONFIG_PATH to $PKG_CONFIG_PATH"
        echo "Set CPPFLAGS to $CPPFLAGS"
        echo "Set LDFLAGS to $LDFLAGS"

        # Debug: Check if pkg-config can find portaudio immediately after setting env vars
        echo "Debug: Testing pkg-config with PKG_CONFIG_PATH and PKG_CONFIG_LIBS..."
        pkg-config --libs --cflags "$PKG_CONFIG_LIBS"

        # Debug: Check if .pc files exist
        echo "Debug: Checking .pc files existence..."
        for lib in $PKG_CONFIG_LIBS; do
          if ! pkg-config --exists "$lib"; then
            echo "ERROR: pkg-config could not locate $lib"
            echo "       PKG_CONFIG_PATH=$PKG_CONFIG_PATH"
            echo "       pkg-config --variable=pc_path pkg-config:"
            pkg-config --variable=pc_path pkg-config || true
            echo "       Contents of $(brew --prefix "$(map_pkg_to_formula "$lib")" 2>/dev/null)/lib/pkgconfig:"
            ls -la "$(brew --prefix "$(map_pkg_to_formula "$lib")" 2>/dev/null)/lib/pkgconfig" || true
            exit 1
          fi
        done

        # Configure clang to work without Command Line Tools
        # This allows Homebrew LLVM to find the macOS SDK
        mkdir -p ~/.config/clang

        # Get Darwin version for config filename
        DARWIN_VERSION=$(uname -r | cut -d. -f1)
        SDK_PATH=$(xcrun --show-sdk-path 2>/dev/null || echo "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk")

        # Create x86_64 config
        cat > ~/.config/clang/x86_64-apple-darwin${DARWIN_VERSION}.cfg << EOF
        # Clang configuration for x86_64 macOS
        -isysroot ${SDK_PATH}
        -isystem ${SDK_PATH}/usr/include
        -stdlib=libc++
        -resource-dir ${BREW_PREFIX}/opt/llvm/lib/clang/21
        EOF

        # Create ARM64 config
        cat > ~/.config/clang/arm64-apple-darwin${DARWIN_VERSION}.cfg << EOF
        # Clang configuration for ARM64 macOS
        -isysroot ${SDK_PATH}
        -isystem ${SDK_PATH}/usr/include
        -stdlib=libc++
        -resource-dir ${BREW_PREFIX}/opt/llvm/lib/clang/21
        EOF

        echo "Created clang config files for darwin${DARWIN_VERSION}"
        ls -la ~/.config/clang/

    - name: Install vcpkg packages (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        if (-not $env:VCPKG_ROOT) {
          Write-Host "VCPKG_ROOT is not set. Please run lukka/run-vcpkg before install-deps." -ForegroundColor Red
          exit 1
        }

        function Install-VcpkgPackages {
          param(
            [string]$PackageList,
            [string]$Triplet
          )

          if ([string]::IsNullOrWhiteSpace($PackageList)) {
            return
          }

          $packages = $PackageList.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
          foreach ($pkg in $packages) {
            Write-Host "Installing vcpkg package: ${pkg}:${Triplet}"
            vcpkg install "${pkg}:${Triplet}"
          }
        }

        Install-VcpkgPackages -PackageList '${{ inputs.vcpkg-packages }}' -Triplet '${{ inputs.vcpkg-triplet }}'
        Install-VcpkgPackages -PackageList '${{ inputs.vcpkg-static-packages }}' -Triplet '${{ inputs.vcpkg-static-triplet }}'

    - name: Save CMake dependency cache (All platforms)
      if: always() && steps.cmake-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          .deps-cache
          deps/bearssl/build
        # Include runner.arch to separate x86_64 and arm64 caches on macOS
        key: ${{ runner.os }}-${{ runner.arch }}-cmake-deps-v6-${{ hashFiles('cmake/dependencies/**') }}

    - name: Save Homebrew cache (macOS)
      if: always() && inputs.os == 'macos' && steps.homebrew-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ~/Library/Caches/Homebrew
        key: ${{ runner.os }}-homebrew-v3-${{ steps.install-deps-sh-hash-macos.outputs.hash }}-${{ inputs.extra-packages }}

    - name: Save vcpkg packages (Windows)
      if: always() && inputs.os == 'windows' && env.VCPKG_ROOT != '' && steps.vcpkg-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/installed
          ${{ env.VCPKG_ROOT }}/packages
          ${{ env.VCPKG_ROOT }}/buildtrees
        key: ${{ runner.os }}-vcpkg-v1-${{ inputs.vcpkg-packages }}-${{ inputs.vcpkg-static-packages }}

    - name: Prepare APT cache for saving (Ubuntu)
      if: always() && inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit != 'true'
      shell: bash
      run: |
        mkdir -p .apt-cache
        if ls /var/cache/apt/archives/*.deb 1>/dev/null 2>&1; then
          cp /var/cache/apt/archives/*.deb .apt-cache/
          echo "Cached $(ls .apt-cache/*.deb | wc -l) .deb files for future runs"
        fi

    - name: Save APT cache (Ubuntu)
      if: always() && inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        # Cache to workspace directory to avoid permission issues
        path: .apt-cache
        key: ${{ runner.os }}-apt-v5-${{ steps.install-deps-sh-hash.outputs.hash }}-${{ inputs.extra-packages }}
