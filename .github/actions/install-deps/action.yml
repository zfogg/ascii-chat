name: 'Install Dependencies'
description: 'Install and cache build dependencies for ascii-chat'
inputs:
  os:
    description: 'Operating system (ubuntu, macos, or windows)'
    required: true
  extra-packages:
    description: 'Additional packages to install (space-separated)'
    required: false
    default: ''
  vcpkg-packages:
    description: 'Space-separated vcpkg packages to install for the primary triplet (Windows only)'
    required: false
    default: ''
  vcpkg-triplet:
    description: 'vcpkg triplet to use for primary packages (Windows only)'
    required: false
    default: 'x64-windows'
  vcpkg-static-packages:
    description: 'Space-separated vcpkg packages to install for the static triplet (Windows only)'
    required: false
    default: ''
  vcpkg-static-triplet:
    description: 'vcpkg triplet to use for static packages (Windows only)'
    required: false
    default: 'x64-windows-static'
  github-token:
    description: 'GitHub token for downloading pre-built tools from releases (Windows only)'
    required: false
    default: ''

outputs:
  defer-tool-path:
    description: 'Path to the defer tool executable (Windows only)'
    value: ${{ steps.download-prebuilt.outputs.defer-tool-path }}
  cmake-cache-key:
    description: 'Cache key for CMake dependencies (computed by cache-keys step)'
    value: ${{ steps.cache-keys.outputs.cmake-cache-key || steps.cache-keys-win.outputs.cmake-cache-key }}
  cmake-cache-hit:
    description: 'Whether CMake dependency cache was hit'
    value: ${{ steps.cmake-cache.outputs.cache-hit }}
  ccache-key:
    description: 'Cache key for ccache (computed by cache-keys step)'
    value: ${{ steps.cache-keys.outputs.ccache-key || steps.cache-keys-win.outputs.ccache-key }}
  ccache-hit:
    description: 'Whether ccache was hit'
    value: ${{ steps.ccache-restore.outputs.cache-hit }}
  build-cache-key:
    description: 'Cache key for build directory (computed by cache-keys step)'
    value: ${{ steps.cache-keys.outputs.build-cache-key || steps.cache-keys-win.outputs.build-cache-key }}

runs:
  using: 'composite'
  steps:
    # =========================================================================
    # CMake 4.2.0 Installation (macOS and Windows only)
    # =========================================================================
    # NOTE: Ubuntu uses scripts/install-deps.sh which installs CMake via Kitware APT repo

    # NOTE: macOS CMake is installed via Homebrew in install-deps.sh

    - name: Install CMake 4.2.0 (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $CMAKE_VERSION = "4.2.0"
        $CMAKE_URL = "https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-windows-x86_64.zip"
        $CMAKE_INSTALL_DIR = "C:\cmake-${CMAKE_VERSION}"

        Write-Host "Installing CMake ${CMAKE_VERSION} from official release..."
        $tempZip = "$env:TEMP\cmake.zip"
        Invoke-WebRequest -Uri $CMAKE_URL -OutFile $tempZip -UseBasicParsing

        # Extract to install directory
        if (Test-Path $CMAKE_INSTALL_DIR) {
          Remove-Item -Recurse -Force $CMAKE_INSTALL_DIR
        }
        Expand-Archive -Path $tempZip -DestinationPath "C:\"
        Rename-Item -Path "C:\cmake-${CMAKE_VERSION}-windows-x86_64" -NewName "cmake-${CMAKE_VERSION}"
        Remove-Item $tempZip

        # Add to PATH (prepend so it takes priority)
        $CMAKE_BIN_DIR = "${CMAKE_INSTALL_DIR}\bin"
        Add-Content -Path $env:GITHUB_PATH -Value $CMAKE_BIN_DIR
        Write-Host "Installed CMake ${CMAKE_VERSION} to ${CMAKE_INSTALL_DIR}"
        & "${CMAKE_BIN_DIR}\cmake.exe" --version

    # =========================================================================
    # Dependency Caches
    # =========================================================================
    - name: Compute install-deps.sh hash (for cmake cache key)
      id: install-deps-hash
      shell: bash
      run: |
        # Hash install-deps.sh to invalidate cmake-deps cache when system packages change
        # This ensures the defer tool gets rebuilt when Clang packages are updated
        if command -v sha256sum &>/dev/null; then
          hash=$(sha256sum scripts/install-deps.sh | cut -c1-8)
        else
          hash=$(shasum -a 256 scripts/install-deps.sh | cut -c1-8)
        fi
        echo "hash=$hash" >> $GITHUB_OUTPUT
        echo "install-deps.sh hash for cmake cache: $hash"

    # Compute all cache keys in steps (hashFiles() and github.ref_name are not available in outputs)
    - name: Compute cache keys (Unix)
      if: inputs.os != 'windows'
      id: cache-keys
      shell: bash
      run: |
        # Compute deps hash from cmake/dependencies files
        if command -v sha256sum &>/dev/null; then
          deps_hash=$(find cmake/dependencies -type f -exec sha256sum {} \; 2>/dev/null | sort | sha256sum | cut -c1-16)
        else
          deps_hash=$(find cmake/dependencies -type f -exec shasum -a 256 {} \; 2>/dev/null | sort | shasum -a 256 | cut -c1-16)
        fi

        # Get branch name from GITHUB_REF
        branch="${GITHUB_REF_NAME:-master}"

        # Get runner info
        os="${RUNNER_OS}"
        arch="${RUNNER_ARCH}"
        install_hash="${{ steps.install-deps-hash.outputs.hash }}"

        # Output cache keys
        # v11/v4: Invalidate caches corrupted by previous 'if: always()' saves
        echo "cmake-cache-key=${os}-${arch}-cmake-deps-v11-${deps_hash}-${install_hash}" >> $GITHUB_OUTPUT
        echo "ccache-key=${os}-${arch}-ccache-v1-${branch}" >> $GITHUB_OUTPUT
        echo "build-cache-key=${os}-${arch}-build-v4-${branch}" >> $GITHUB_OUTPUT

        echo "Computed cache keys:"
        echo "  cmake: ${os}-${arch}-cmake-deps-v11-${deps_hash}-${install_hash}"
        echo "  ccache: ${os}-${arch}-ccache-v1-${branch}"
        echo "  build: ${os}-${arch}-build-v4-${branch}"

    - name: Compute cache keys (Windows)
      if: inputs.os == 'windows'
      id: cache-keys-win
      shell: pwsh
      run: |
        # Compute deps hash from cmake/dependencies files
        $files = Get-ChildItem -Path "cmake/dependencies" -File -Recurse | Sort-Object FullName
        $hashes = $files | ForEach-Object {
          $hash = Get-FileHash -Path $_.FullName -Algorithm SHA256
          "$($hash.Hash) $($_.FullName)"
        }
        $combinedHash = ($hashes -join "`n" | Out-String)
        $bytes = [System.Text.Encoding]::UTF8.GetBytes($combinedHash)
        $sha256 = [System.Security.Cryptography.SHA256]::Create()
        $hashBytes = $sha256.ComputeHash($bytes)
        $depsHash = [BitConverter]::ToString($hashBytes).Replace("-", "").Substring(0, 16).ToLower()

        # Get branch name from GITHUB_REF_NAME
        $branch = if ($env:GITHUB_REF_NAME) { $env:GITHUB_REF_NAME } else { "master" }

        # Get runner info
        $os = $env:RUNNER_OS
        $arch = $env:RUNNER_ARCH
        $installHash = "${{ steps.install-deps-hash.outputs.hash }}"

        # Output cache keys
        # v11/v4: Invalidate caches corrupted by previous 'if: always()' saves
        Add-Content -Path $env:GITHUB_OUTPUT -Value "cmake-cache-key=${os}-${arch}-cmake-deps-v11-${depsHash}-${installHash}"
        Add-Content -Path $env:GITHUB_OUTPUT -Value "ccache-key=${os}-${arch}-ccache-v1-${branch}"
        Add-Content -Path $env:GITHUB_OUTPUT -Value "build-cache-key=${os}-${arch}-build-v4-${branch}"

        Write-Host "Computed cache keys:"
        Write-Host "  cmake: ${os}-${arch}-cmake-deps-v11-${depsHash}-${installHash}"
        Write-Host "  ccache: ${os}-${arch}-ccache-v1-${branch}"
        Write-Host "  build: ${os}-${arch}-build-v4-${branch}"

    - name: Restore CMake dependency cache (All platforms)
      id: cmake-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          .deps-cache
          deps/bearssl/build
        # Use computed key from cache-keys step (hashFiles not available in composite actions)
        # v8: Fix cache timing - cache is now saved by workflows AFTER cmake configure
        key: ${{ steps.cache-keys.outputs.cmake-cache-key || steps.cache-keys-win.outputs.cmake-cache-key }}

    # Restore ccache for incremental compilation across CI runs
    # Key includes branch name so each branch has its own cache, with fallback to any branch's cache
    - name: Restore ccache (All platforms)
      id: ccache-restore
      uses: actions/cache/restore@v4
      with:
        path: .ccache
        # Use computed key from cache-keys step (github.ref_name not available in composite actions)
        key: ${{ steps.cache-keys.outputs.ccache-key || steps.cache-keys-win.outputs.ccache-key }}
        restore-keys: |
          ${{ runner.os }}-${{ runner.arch }}-ccache-v1-

    # Set CCACHE_DIR to workspace-relative path for consistent caching
    - name: Configure ccache directory (Unix)
      if: inputs.os != 'windows'
      shell: bash
      run: |
        mkdir -p .ccache
        echo "CCACHE_DIR=${{ github.workspace }}/.ccache" >> $GITHUB_ENV
        echo "CCACHE_MAXSIZE=500M" >> $GITHUB_ENV
        echo "CCACHE_COMPRESS=1" >> $GITHUB_ENV

    - name: Configure ccache directory (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Force -Path .ccache | Out-Null
        Add-Content -Path $env:GITHUB_ENV -Value "CCACHE_DIR=${{ github.workspace }}\.ccache"
        Add-Content -Path $env:GITHUB_ENV -Value "CCACHE_MAXSIZE=500M"
        Add-Content -Path $env:GITHUB_ENV -Value "CCACHE_COMPRESS=1"

    # Restore build directory for incremental builds
    # Same key per branch - Ninja handles rebuilding only changed files
    - name: Restore build directory (All platforms)
      id: build-cache-restore
      uses: actions/cache/restore@v4
      with:
        path: build_release
        # Use computed key from cache-keys step (github.ref_name not available in composite actions)
        key: ${{ steps.cache-keys.outputs.build-cache-key || steps.cache-keys-win.outputs.build-cache-key }}

    - name: Compute install-deps.sh hash (macOS)
      if: inputs.os == 'macos'
      id: install-deps-sh-hash-macos
      shell: bash
      run: |
        # Use scripts/install-deps.sh as the single source of truth for package installation
        # Hash the install-deps.sh script to invalidate cache when dependencies change
        hash=$(shasum -a 256 scripts/install-deps.sh | cut -c1-8)
        echo "hash=$hash" >> $GITHUB_OUTPUT
        echo "install-deps.sh hash: $hash"

    - name: Restore Homebrew cache (macOS)
      if: inputs.os == 'macos'
      id: homebrew-cache
      uses: actions/cache/restore@v4
      with:
        # NOTE: GitHub-hosted macOS runners already populate /opt/homebrew with
        # a Homebrew installation. Restoring cached copies of /opt/homebrew/*
        # causes tar extractions to fail when a package (e.g. pydantic-core) is
        # already present, so only cache the download artifacts.
        path: |
          ~/Library/Caches/Homebrew
        key: ${{ runner.os }}-homebrew-v3-${{ steps.install-deps-sh-hash-macos.outputs.hash }}-${{ inputs.extra-packages }}
        restore-keys: |
          ${{ runner.os }}-homebrew-v3-${{ steps.install-deps-sh-hash-macos.outputs.hash }}-
          ${{ runner.os }}-homebrew-v3-

    - name: Install dependencies via scripts/install-deps.sh (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        set -euo pipefail

        echo "Running scripts/install-deps.sh to install build dependencies..."
        # install-deps.sh handles all Homebrew package installation
        bash scripts/install-deps.sh

        # Install any extra packages requested by the workflow
        extra="${{ inputs.extra-packages }}"
        if [ -n "$extra" ]; then
          echo "Installing additional packages: $extra"
          brew install $extra
        fi

        # Clean up to reduce cache size
        brew cleanup

    - name: Compute install-deps.sh hash (Ubuntu)
      if: inputs.os == 'ubuntu'
      id: install-deps-sh-hash
      shell: bash
      run: |
        # Use scripts/install-deps.sh as the single source of truth for package installation
        # Hash the install-deps.sh script to invalidate cache when dependencies change
        hash=$(sha256sum scripts/install-deps.sh | cut -c1-8)
        echo "hash=$hash" >> $GITHUB_OUTPUT
        echo "install-deps.sh hash: $hash"

    - name: Restore APT cache (Ubuntu)
      if: inputs.os == 'ubuntu'
      id: apt-cache
      uses: actions/cache/restore@v4
      with:
        # Cache to workspace directory to avoid permission issues
        path: .apt-cache
        key: ${{ runner.os }}-apt-v5-${{ steps.install-deps-sh-hash.outputs.hash }}-${{ inputs.extra-packages }}
        restore-keys: |
          ${{ runner.os }}-apt-v5-${{ steps.install-deps-sh-hash.outputs.hash }}-
          ${{ runner.os }}-apt-v5-

    - name: Restore APT cache to system (Ubuntu)
      if: inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit == 'true'
      shell: bash
      run: |
        if [ -d ".apt-cache" ] && [ "$(ls -A .apt-cache 2>/dev/null)" ]; then
          echo "Restoring $(ls .apt-cache/*.deb 2>/dev/null | wc -l) cached .deb files..."
          sudo cp .apt-cache/*.deb /var/cache/apt/archives/ 2>/dev/null || true
        fi

    - name: Disable problematic Microsoft APT repos (Ubuntu)
      if: inputs.os == 'ubuntu'
      shell: bash
      run: |
        # Microsoft's Azure CLI repos sometimes return 403 errors on GitHub Actions
        # Disable them since we don't need Azure CLI for building ascii-chat
        for repo in /etc/apt/sources.list.d/microsoft*.list /etc/apt/sources.list.d/azure*.list; do
          if [[ -f "$repo" ]]; then
            echo "Disabling problematic repo: $repo"
            sudo mv "$repo" "$repo.disabled" || true
          fi
        done

    - name: Install dependencies via scripts/install-deps.sh (Ubuntu)
      if: inputs.os == 'ubuntu'
      shell: bash
      run: |
        set -euo pipefail

        echo "Running scripts/install-deps.sh to install build dependencies..."
        # install-deps.sh handles:
        # - CMake 4.2.0 installation via Kitware APT repository
        # - All build dependencies (clang-21, llvm-21-dev, etc.)
        # - LLVM 21 update-alternatives configuration
        # --dangerously-delete-conflicts: GitHub runners have pre-installed binaries
        # in /usr/bin that shadow update-alternatives. The flag allows deletion
        # only when CI=true (set by GitHub Actions).
        bash scripts/install-deps.sh --dangerously-delete-conflicts

        # Install any extra packages requested by the workflow
        extra="${{ inputs.extra-packages }}"
        if [ -n "$extra" ]; then
          echo "Installing additional packages: $extra"
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends $extra
        fi

    - name: Restore vcpkg packages (Windows)
      if: inputs.os == 'windows' && env.VCPKG_ROOT != ''
      id: vcpkg-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/installed
          ${{ env.VCPKG_ROOT }}/packages
          ${{ env.VCPKG_ROOT }}/buildtrees
        key: ${{ runner.os }}-vcpkg-v1-${{ inputs.vcpkg-packages }}-${{ inputs.vcpkg-static-packages }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-v1-

    - name: Set CSTD env var (POSIX)
      if: inputs.os != 'windows'
      shell: bash
      run: |
        # Setup CSTD
        export CSTD=c2x
        echo "CSTD=$CSTD" >> $GITHUB_ENV
        echo "Set CSTD to $CSTD"

    - name: Set CSTD env var (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $value = 'c2x'
        Add-Content -Path $env:GITHUB_ENV -Value "CSTD=$value"
        Write-Host "Set CSTD to $value"

    - name: Install Windows build tools (scoop)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        function Ensure-Scoop {
          if (Get-Command scoop -ErrorAction SilentlyContinue) {
            Write-Host "Scoop already installed"
            return
          }

          Write-Host "Scoop not found. Installing scoop..."
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
          Invoke-RestMethod get.scoop.sh | Invoke-Expression
        }

        function Ensure-ScoopBucket {
          param(
            [string]$Bucket
          )

          # Use try/catch for robustness - scoop bucket add is idempotent
          try {
            $buckets = scoop bucket list 2>$null
            if ($buckets -notmatch [regex]::Escape($Bucket)) {
              Write-Host "Adding scoop bucket: $Bucket"
              scoop bucket add $Bucket 2>$null | Out-Null
            }
          } catch {
            Write-Host "Adding scoop bucket: $Bucket (first time)"
            scoop bucket add $Bucket 2>$null | Out-Null
          }
        }

        function Install-ScoopPackage {
          param(
            [string]$Package
          )

          if ([string]::IsNullOrWhiteSpace($Package)) {
            return
          }

          # Check if package is installed using string matching
          $installed = scoop list 2>$null | Out-String
          if ($installed -match "(?m)^\s*$([regex]::Escape($Package))\s") {
            Write-Host "Package already installed via scoop: $Package"
          }
          else {
            Write-Host "Installing scoop package: $Package"
            scoop install $Package --global
          }
        }

        Ensure-Scoop
        Ensure-ScoopBucket -Bucket 'main'
        Ensure-ScoopBucket -Bucket 'extras'

        # NOTE: LLVM is installed separately from vovkos/llvm-package-windows
        # because scoop/choco/winget LLVM packages don't include dev libraries
        # doxygen is needed for generating documentation included in installers
        # NOTE: git is already pre-installed on GitHub Actions Windows runners
        $basePackages = @('ninja', 'ccache', 'doxygen')

        $extra = @()
        if (-not [string]::IsNullOrWhiteSpace('${{ inputs.extra-packages }}')) {
          $extra = '${{ inputs.extra-packages }}'.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
        }
        $packages = $basePackages + $extra

        foreach ($pkg in $packages) {
          Install-ScoopPackage -Package $pkg
        }

        # Add scoop shims to PATH (both user and global locations)
        # Global installs (--global) go to C:\ProgramData\scoop
        $scoopShimsUser = Join-Path $env:USERPROFILE 'scoop\shims'
        $scoopShimsGlobal = 'C:\ProgramData\scoop\shims'
        $foundShims = $false
        foreach ($shimsPath in @($scoopShimsGlobal, $scoopShimsUser)) {
          if (Test-Path $shimsPath) {
            Write-Host "Adding scoop shims to PATH: $shimsPath"
            Add-Content -Path $env:GITHUB_PATH -Value $shimsPath
            $foundShims = $true
          }
        }
        if (-not $foundShims) {
          Write-Host "No scoop shims found"
          exit 1
        }

    # =========================================================================
    # LLVM with Development Libraries (Windows)
    # =========================================================================
    # The official LLVM Windows installer and scoop/choco/winget packages only
    # include compiler binaries (clang.exe), NOT the development libraries
    # (LLVMSupport.lib, clangTooling.lib, etc.) needed to build the defer tool.
    # AMD64: Use vovkos/llvm-package-windows which provides full LLVM dev libraries.
    # ARM64: Use official LLVM woa64 installer (LLVM 19.x has native ARM64 support).
    - name: Install LLVM with dev libraries (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $arch = "${{ runner.arch }}"
        Write-Host "Detected architecture: $arch"

        if ($arch -eq "X64") {
          # AMD64: Download from vovkos/llvm-package-windows
          $LLVM_VERSION = "20.1.8"
          $LLVM_INSTALL_DIR = "C:\LLVM"
          $LLVM_ARCHIVE = "clang-${LLVM_VERSION}-windows-amd64-msvc17-msvcrt.7z"
          $LLVM_URL = "https://github.com/vovkos/llvm-package-windows/releases/download/clang-${LLVM_VERSION}/${LLVM_ARCHIVE}"

          if (Test-Path "${LLVM_INSTALL_DIR}\lib\LLVMSupport.lib") {
            Write-Host "LLVM with dev libraries already installed at ${LLVM_INSTALL_DIR}"
          } else {
            Write-Host "Downloading LLVM ${LLVM_VERSION} with dev libraries from vovkos/llvm-package-windows..."
            $tempArchive = "$env:TEMP\${LLVM_ARCHIVE}"
            Invoke-WebRequest -Uri $LLVM_URL -OutFile $tempArchive -UseBasicParsing
            Write-Host "Downloaded to ${tempArchive}"

            if (Test-Path $LLVM_INSTALL_DIR) {
              Remove-Item -Recurse -Force $LLVM_INSTALL_DIR
            }

            Write-Host "Extracting LLVM to ${LLVM_INSTALL_DIR}..."
            # Download standalone 7zr.exe (small ~500KB extractor, no install needed)
            $7zrUrl = "https://www.7-zip.org/a/7zr.exe"
            $7zr = "$env:TEMP\7zr.exe"
            Invoke-WebRequest -Uri $7zrUrl -OutFile $7zr -UseBasicParsing
            & $7zr x $tempArchive -o"C:\" -y | Out-Null
            Remove-Item $7zr -Force

            $extractedDir = "C:\clang-${LLVM_VERSION}-windows-amd64-msvc17-msvcrt"
            if (Test-Path $extractedDir) {
              Rename-Item -Path $extractedDir -NewName "LLVM"
            }
            Remove-Item $tempArchive -Force

            # Verify installation
            if (Test-Path "${LLVM_INSTALL_DIR}\lib\clangTooling.lib") {
              Write-Host "LLVM ${LLVM_VERSION} with dev libraries installed successfully"
            } else {
              Write-Host "ERROR: clangTooling.lib not found" -ForegroundColor Red
              exit 1
            }
          }

          $llvmBinPath = "${LLVM_INSTALL_DIR}\bin"
        } else {
          # ARM64: Download official LLVM woa64 installer (GitHub releases)
          # LLVM 21.x doesn't ship woa64 binaries, so use 19.1.6 which has native ARM64 support
          $LLVM_ARM64_VERSION = "19.1.6"
          $LLVM_ARM64_URL = "https://github.com/llvm/llvm-project/releases/download/llvmorg-${LLVM_ARM64_VERSION}/LLVM-${LLVM_ARM64_VERSION}-woa64.exe"
          Write-Host "Detected architecture: ARM64"
          Write-Host "Installing official LLVM ${LLVM_ARM64_VERSION} for Windows ARM64..."

          $installerPath = "$env:TEMP\LLVM-${LLVM_ARM64_VERSION}-woa64.exe"
          Write-Host "Downloading from: $LLVM_ARM64_URL"
          Invoke-WebRequest -Uri $LLVM_ARM64_URL -OutFile $installerPath -UseBasicParsing

          # Run installer silently (NSIS installer uses /S for silent mode)
          # Install to C:\LLVM-ARM64 to avoid conflicts with x64 LLVM
          $LLVM_ARM64_INSTALL_DIR = "C:\LLVM-ARM64"
          Write-Host "Running silent installer to ${LLVM_ARM64_INSTALL_DIR}..."
          Start-Process -Wait -FilePath $installerPath -ArgumentList "/S","/D=${LLVM_ARM64_INSTALL_DIR}"
          Remove-Item $installerPath -Force -ErrorAction SilentlyContinue

          $llvmBinPath = "${LLVM_ARM64_INSTALL_DIR}\bin"
          if (-not (Test-Path "$llvmBinPath\clang.exe")) {
            Write-Host "ERROR: LLVM ARM64 installation failed - clang.exe not found" -ForegroundColor Red
            Get-ChildItem -Path $LLVM_ARM64_INSTALL_DIR -Recurse -ErrorAction SilentlyContinue | Select-Object -First 20
            exit 1
          }
          Write-Host "LLVM ${LLVM_ARM64_VERSION} ARM64 installed successfully"

          # For ARM64: Also set LLVM/Clang CMake directories so CMake finds the right installation
          # and remove or hide any conflicting x64 LLVM
          $llvmCMakeDir = "${LLVM_ARM64_INSTALL_DIR}\lib\cmake\llvm"
          $clangCMakeDir = "${LLVM_ARM64_INSTALL_DIR}\lib\cmake\clang"
          if (Test-Path $llvmCMakeDir) {
            Add-Content -Path $env:GITHUB_ENV -Value "LLVM_DIR=${llvmCMakeDir}"
            Write-Host "Set LLVM_DIR: ${llvmCMakeDir}"
          }
          if (Test-Path $clangCMakeDir) {
            Add-Content -Path $env:GITHUB_ENV -Value "Clang_DIR=${clangCMakeDir}"
            Write-Host "Set Clang_DIR: ${clangCMakeDir}"
          }

          # Rename conflicting x64 LLVM if present (so llvm-config isn't found there)
          if (Test-Path "C:\Program Files\LLVM") {
            Write-Host "Renaming conflicting x64 LLVM at 'C:\Program Files\LLVM'"
            Rename-Item -Path "C:\Program Files\LLVM" -NewName "LLVM-x64-disabled" -ErrorAction SilentlyContinue
          }

          # Set vcpkg triplet for ARM64 to ensure CMake uses ARM64 packages
          Add-Content -Path $env:GITHUB_ENV -Value "VCPKG_TARGET_TRIPLET=arm64-windows-static"
          Write-Host "Set VCPKG_TARGET_TRIPLET: arm64-windows-static"
        }

        Write-Host "Adding LLVM to PATH: ${llvmBinPath}"
        # Prepend to PATH so our LLVM is found first
        Add-Content -Path $env:GITHUB_PATH -Value $llvmBinPath
        Add-Content -Path $env:GITHUB_ENV -Value "CC=${llvmBinPath}\clang.exe"
        Add-Content -Path $env:GITHUB_ENV -Value "CXX=${llvmBinPath}\clang++.exe"
        & "${llvmBinPath}\clang.exe" --version

    - name: Set up build environment (macOS)
      if: inputs.os == 'macos'
      shell: bash
      run: |
        BREW_PREFIX="$(brew --prefix)"
        echo "Detected Homebrew prefix: ${BREW_PREFIX}"

        # NOTE: `brew info make` says "make" is installed as "gmake", but they give us gnubin
        if [ -d "${BREW_PREFIX}/opt/make/libexec/gnubin" ]; then
          export PATH="${BREW_PREFIX}/opt/make/libexec/gnubin:$PATH"
        fi
        if [ -d "${BREW_PREFIX}/opt/llvm/bin" ]; then
          export PATH="${BREW_PREFIX}/opt/llvm/bin:$PATH"
        fi

        export PKG_CONFIG_LIBS="portaudio-2.0 criterion libzstd libsodium"
        export PKG_CONFIG_PATH="${BREW_PREFIX}/lib/pkgconfig:${BREW_PREFIX}/share/pkgconfig"
        export CPPFLAGS="-I${BREW_PREFIX}/include"
        export LDFLAGS="-L${BREW_PREFIX}/lib"

        # NOTE: Do NOT add -lunwind here - macOS provides its own unwind library
        # Linking to Homebrew's libunwind causes static linking check failures
        # as the binary would depend on /opt/homebrew/opt/llvm/lib/unwind/libunwind.1.dylib
        if [ -d "${BREW_PREFIX}/opt/llvm/lib/c++" ]; then
          export LDFLAGS="$LDFLAGS -L${BREW_PREFIX}/opt/llvm/lib/c++"
        fi

        map_pkg_to_formula() {
          case "$1" in
            portaudio-2.0) echo "portaudio" ;;
            libzstd) echo "zstd" ;;
            libsodium) echo "libsodium" ;;
            criterion) echo "criterion" ;;
            *) echo "$1" ;;
          esac
        }

        append_pkgconfig_path_if_exists() {
          local dir="$1"
          if [ -d "$dir" ]; then
            if [[ ":$PKG_CONFIG_PATH:" != *":$dir:"* ]]; then
              PKG_CONFIG_PATH="${PKG_CONFIG_PATH}:$dir"
            fi
          fi
        }

        for lib in $PKG_CONFIG_LIBS; do
          formula="$(map_pkg_to_formula "$lib")"
          if prefix="$(brew --prefix "$formula" 2>/dev/null)"; then
            append_pkgconfig_path_if_exists "${prefix}/lib/pkgconfig"
            append_pkgconfig_path_if_exists "${prefix}/share/pkgconfig"
          fi
        done

        # Set up PATH
        echo "PATH=$PATH" >> $GITHUB_ENV

        # Set up pkg-config path for Homebrew packages (always needed)
        echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
        echo "CPPFLAGS=$CPPFLAGS" >> $GITHUB_ENV
        echo "LDFLAGS=$LDFLAGS" >> $GITHUB_ENV
        echo "PKG_CONFIG_LIBS=$PKG_CONFIG_LIBS" >> $GITHUB_ENV

        # Verify they will be set for subsequent steps
        echo "Set PKG_CONFIG_PATH to $PKG_CONFIG_PATH"
        echo "Set CPPFLAGS to $CPPFLAGS"
        echo "Set LDFLAGS to $LDFLAGS"

        # Debug: Check if pkg-config can find portaudio immediately after setting env vars
        echo "Debug: Testing pkg-config with PKG_CONFIG_PATH and PKG_CONFIG_LIBS..."
        pkg-config --libs --cflags "$PKG_CONFIG_LIBS"

        # Debug: Check if .pc files exist
        echo "Debug: Checking .pc files existence..."
        for lib in $PKG_CONFIG_LIBS; do
          if ! pkg-config --exists "$lib"; then
            echo "ERROR: pkg-config could not locate $lib"
            echo "       PKG_CONFIG_PATH=$PKG_CONFIG_PATH"
            echo "       pkg-config --variable=pc_path pkg-config:"
            pkg-config --variable=pc_path pkg-config || true
            echo "       Contents of $(brew --prefix "$(map_pkg_to_formula "$lib")" 2>/dev/null)/lib/pkgconfig:"
            ls -la "$(brew --prefix "$(map_pkg_to_formula "$lib")" 2>/dev/null)/lib/pkgconfig" || true
            exit 1
          fi
        done

        # Configure clang to work without Command Line Tools
        # This allows Homebrew LLVM to find the macOS SDK
        mkdir -p ~/.config/clang

        # Get Darwin version for config filename
        DARWIN_VERSION=$(uname -r | cut -d. -f1)
        SDK_PATH=$(xcrun --show-sdk-path 2>/dev/null || echo "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk")

        # Create x86_64 config
        cat > ~/.config/clang/x86_64-apple-darwin${DARWIN_VERSION}.cfg << EOF
        # Clang configuration for x86_64 macOS
        -isysroot ${SDK_PATH}
        -isystem ${SDK_PATH}/usr/include
        -stdlib=libc++
        -resource-dir ${BREW_PREFIX}/opt/llvm/lib/clang/21
        EOF

        # Create ARM64 config
        cat > ~/.config/clang/arm64-apple-darwin${DARWIN_VERSION}.cfg << EOF
        # Clang configuration for ARM64 macOS
        -isysroot ${SDK_PATH}
        -isystem ${SDK_PATH}/usr/include
        -stdlib=libc++
        -resource-dir ${BREW_PREFIX}/opt/llvm/lib/clang/21
        EOF

        echo "Created clang config files for darwin${DARWIN_VERSION}"
        ls -la ~/.config/clang/


    - name: Setup vcpkg (Windows)
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: "80d025e8299d442c13b29751fc9451711b7c6c8e"

    - name: Install vcpkg packages (Windows)
      if: inputs.os == 'windows'
      shell: pwsh
      run: |
        if (-not $env:VCPKG_ROOT) {
          Write-Host "VCPKG_ROOT is not set. Please run lukka/run-vcpkg before install-deps." -ForegroundColor Red
          exit 1
        }

        function Install-VcpkgPackages {
          param(
            [string]$PackageList,
            [string]$Triplet
          )

          if ([string]::IsNullOrWhiteSpace($PackageList)) {
            return
          }

          $packages = $PackageList.Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
          foreach ($pkg in $packages) {
            Write-Host "Installing vcpkg package: ${pkg}:${Triplet}"
            vcpkg install "${pkg}:${Triplet}"
          }
        }

        Install-VcpkgPackages -PackageList '${{ inputs.vcpkg-packages }}' -Triplet '${{ inputs.vcpkg-triplet }}'
        Install-VcpkgPackages -PackageList '${{ inputs.vcpkg-static-packages }}' -Triplet '${{ inputs.vcpkg-static-triplet }}'


    # =========================================================================
    # Pre-built Tools Download (Windows)
    # =========================================================================
    # Try to download pre-built defer tool and BearSSL from build-tools release
    # This avoids needing full LLVM dev libraries and nmake build issues
    # If build-tools release doesn't exist, CMake will build from source
    # AMD64: Try to download pre-built binaries, fall back to source build
    # ARM64: Will be built from source by CMake (no pre-built ARM64 binaries yet)
    - name: Download pre-built tools (Windows)
      id: download-prebuilt
      if: inputs.os == 'windows' && inputs.github-token != ''
      shell: pwsh
      run: |
        $arch = "${{ runner.arch }}"
        Write-Host "Detected architecture: $arch"

        if ($arch -eq "X64") {
          # AMD64: Try to download pre-built binaries
          $deferToolDir = Join-Path $PWD ".deps-cache" "defer-tool"
          New-Item -ItemType Directory -Force -Path $deferToolDir | Out-Null

          # Check if build-tools release exists
          $releaseExists = $false
          try {
            $result = gh release view build-tools --json tagName 2>&1
            if ($LASTEXITCODE -eq 0) {
              $releaseExists = $true
              Write-Host "Found build-tools release, attempting to download pre-built binaries..."
            }
          } catch {
            Write-Host "build-tools release not found, will build from source"
          }

          if ($releaseExists) {
            try {
              gh release download build-tools --pattern "ascii-instr-defer-Windows-AMD64.exe" --dir $deferToolDir
              gh release download build-tools --pattern "zlib1.dll" --dir $deferToolDir
              gh release download build-tools --pattern "zstd.dll" --dir $deferToolDir
              $srcPath = Join-Path $deferToolDir "ascii-instr-defer-Windows-AMD64.exe"
              $dstPath = Join-Path $deferToolDir "ascii-instr-defer.exe"
              Move-Item -Path $srcPath -Destination $dstPath -Force
              Write-Host "Downloaded defer tool to: $dstPath"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "defer-tool-path=$dstPath"

              # Download pre-built BearSSL
              $bearsslDir = Join-Path $PWD ".deps-cache" "Release" "bearssl"
              New-Item -ItemType Directory -Force -Path $bearsslDir | Out-Null
              gh release download build-tools --pattern "bearssls-Windows-AMD64.lib" --dir $bearsslDir
              $srcPathBearssl = Join-Path $bearsslDir "bearssls-Windows-AMD64.lib"
              $dstPathBearssl = Join-Path $bearsslDir "bearssls.lib"
              Move-Item -Path $srcPathBearssl -Destination $dstPathBearssl -Force
              Write-Host "Downloaded BearSSL to: $dstPathBearssl"
            } catch {
              Write-Host "Failed to download pre-built binaries: $_"
              Write-Host "Will build from source instead"
              Add-Content -Path $env:GITHUB_OUTPUT -Value "defer-tool-path="
            }
          } else {
            Write-Host "No build-tools release available - defer tool and BearSSL will be built from source"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "defer-tool-path="
          }
        } else {
          # ARM64: No pre-built binaries available - CMake will build from source
          Write-Host "ARM64: No pre-built binaries available - defer tool and BearSSL will be built from source"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "defer-tool-path="
        }
      env:
        GH_TOKEN: ${{ inputs.github-token }}

    # NOTE: CMake dependency cache is saved by the workflow files (build.yml, release.yml)
    # AFTER cmake configure runs, not here. This ensures BearSSL and other deps built
    # during cmake configure are included in the cache.

    - name: Save Homebrew cache (macOS)
      if: always() && inputs.os == 'macos' && steps.homebrew-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ~/Library/Caches/Homebrew
        key: ${{ runner.os }}-homebrew-v3-${{ steps.install-deps-sh-hash-macos.outputs.hash }}-${{ inputs.extra-packages }}

    - name: Save vcpkg packages (Windows)
      if: always() && inputs.os == 'windows' && env.VCPKG_ROOT != '' && steps.vcpkg-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/installed
          ${{ env.VCPKG_ROOT }}/packages
          ${{ env.VCPKG_ROOT }}/buildtrees
        key: ${{ runner.os }}-vcpkg-v1-${{ inputs.vcpkg-packages }}-${{ inputs.vcpkg-static-packages }}

    - name: Prepare APT cache for saving (Ubuntu)
      if: always() && inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit != 'true'
      shell: bash
      run: |
        mkdir -p .apt-cache
        if ls /var/cache/apt/archives/*.deb 1>/dev/null 2>&1; then
          cp /var/cache/apt/archives/*.deb .apt-cache/
          echo "Cached $(ls .apt-cache/*.deb | wc -l) .deb files for future runs"
        fi

    - name: Save APT cache (Ubuntu)
      if: always() && inputs.os == 'ubuntu' && steps.apt-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        # Cache to workspace directory to avoid permission issues
        path: .apt-cache
        key: ${{ runner.os }}-apt-v5-${{ steps.install-deps-sh-hash.outputs.hash }}-${{ inputs.extra-packages }}
