/**
 * @page topic_network Network README
 * @ingroup network
 *
 * @section network_overview Overview
 *
 * Welcome to the Network I/O module! This is where all the network communication
 * happens—everything from basic socket operations to packet transmission. The network
 * module is designed for real-time video streaming, which means it's optimized for
 * low latency, reliability, and handling large data transfers smoothly.
 *
 * What does the network module do?
 * --------------------------------
 * The Network I/O module provides fundamental network operations that everything
 * else builds on. Think of it as the foundation for all network communication.
 * Here's what it handles:
 * - **Socket I/O operations** with timeout support (so operations don't hang forever)
 * - **Connection management** (connect, accept) with timeouts (critical for reliable
 *   connections)
 * - **Socket configuration** (keepalive, non-blocking mode, timeouts) to keep
 *   connections healthy
 * - **Chunked transmission** for large data transfers (so big video frames don't
 *   block the connection)
 * - **Packet protocol** with encryption and compression support (built on top of
 *   the basic I/O)
 * - **Error reporting and diagnostics** (so you know what went wrong when things
 *   break)
 *
 * All operations support configurable timeouts, which is critical for real-time
 * video streaming—we can't afford to wait forever when something goes wrong.
 * The timeout system ensures that operations fail fast rather than hanging indefinitely.
 *
 * **Implementation**: lib/network/network.h, lib/network/packet.h
 *
 * @section network_architecture Architecture
 *
 * The network module is built around a few key concepts: timeouts to prevent
 * hanging, socket configuration to keep connections healthy, and a packet protocol
 * that handles the complexity of reliable data transmission. Let's walk through
 * how everything fits together.
 *
 * @subsection network_timeout_system Timeout System
 *
 * All I/O operations support configurable timeouts—this is probably the most
 * important feature for real-time video streaming. Without timeouts, operations
 * can hang forever when the network is flaky, which would freeze your video stream.
 *
 * What timeouts do we have?
 * -------------------------
 * - **Connection timeout**: 3 seconds (`CONNECT_TIMEOUT`)—when you're trying to
 *   connect to a server, we'll give up after 3 seconds rather than waiting forever
 * - **Send timeout**: 5 seconds (`SEND_TIMEOUT`)—when sending data, we'll give
 *   up after 5 seconds if it's not going through
 * - **Receive timeout**: 15 seconds (`RECV_TIMEOUT`)—when receiving data, we'll
 *   wait up to 15 seconds (this is longer because network delays are more common
 *   on receive)
 * - **Accept timeout**: 3 seconds (`ACCEPT_TIMEOUT`)—when waiting for incoming
 *   connections, we'll check every 3 seconds rather than blocking forever
 *
 * Why these values?
 * ----------------
 * These timeouts are tuned specifically for real-time video streaming. They're
 * short enough that you notice problems quickly, but long enough that normal
 * network hiccups don't cause false positives. Chunked transmission prevents
 * large data from blocking indefinitely—even if a single chunk times out, we
 * can still make progress on the rest.
 *
 * @subsection network_socket_configuration Socket Configuration
 *
 * Socket configuration is about keeping your connections healthy and efficient.
 * We configure sockets with several important settings:
 *
 * What socket options do we set?
 * ------------------------------
 * - **TCP keepalive**: This detects dead connections automatically—if the connection
 *   has been idle for a while, keepalive probes check if it's still alive. If the
 *   other end doesn't respond, we know the connection is dead and can clean it up.
 *   We use `KEEPALIVE_IDLE`, `KEEPALIVE_INTERVAL`, and `KEEPALIVE_COUNT` to tune this.
 * - **Non-blocking mode**: This enables asynchronous I/O patterns—instead of blocking
 *   and waiting for data, we can check if data is available and do other work while
 *   waiting
 * - **Socket-level timeouts**: We set `SO_SNDTIMEO` and `SO_RCVTIMEO` at the socket
 *   level, so even if the application doesn't explicitly check timeouts, the socket
 *   itself will time out
 * - **Platform abstraction**: All of this works cross-platform (Linux, macOS, Windows)
 *   through our platform abstraction layer
 *
 * @subsection network_packet_protocol Packet Protocol
 *
 * The packet protocol sits on top of the basic socket I/O and adds structure,
 * validation, encryption, and compression. It's how we reliably transmit data
 * even when the network is unreliable.
 *
 * What does the packet protocol do?
 * ---------------------------------
 * The packet protocol provides:
 * - **Packet header validation**: Every packet starts with a magic number and CRC32
 *   checksum, so we can detect corrupted packets immediately
 * - **Secure packet transmission**: Packets can be encrypted using the crypto context
 *   (automatic encryption/decryption)
 * - **Secure packet reception**: Packets are automatically decrypted and validated
 *   when received
 * - **Automatic compression**: Large packets are automatically compressed to save
 *   bandwidth
 * - **Protocol compliance checking**: We verify that packets follow the protocol
 *   specification, so malformed packets are rejected early
 *
 * How are packets structured?
 * -------------------------
 * **Packet Structure**:
 * - **Header**: Contains a magic number (so we know it's really our packet), type
 *   (what kind of packet it is), length (how much data follows), CRC32 (to detect
 *   corruption), and client ID (which client this is from)
 * - **Payload**: The actual data, which can be encrypted and/or compressed
 * - **Validation**: The CRC32 checksum in the header lets us verify packet integrity
 *   before we even try to decrypt or decompress
 *
 * This structure makes it easy to detect problems early—if the magic number is
 * wrong or the CRC32 doesn't match, we know the packet is corrupted before we
 * waste time trying to decrypt it.
 *
 * @section network_operations Operations
 *
 * @subsection network_io_operations Socket I/O Operations
 *
 * **Send/Receive Operations**:
 * @code{.c}
 * // Send data with timeout
 * ssize_t sent = send_with_timeout(sockfd, data, len, SEND_TIMEOUT);
 * if (sent < 0) {
 *     log_error("Send failed: %s", network_error_string());
 * }
 *
 * // Receive data with timeout
 * ssize_t received = recv_with_timeout(sockfd, buffer, len, RECV_TIMEOUT);
 * if (received < 0) {
 *     log_error("Receive failed: %s", network_error_string());
 * }
 * @endcode
 *
 * **Connection Operations**:
 * @code{.c}
 * // Connect to server with timeout
 * if (!connect_with_timeout(sockfd, &addr, addrlen, CONNECT_TIMEOUT)) {
 *     log_error("Connection failed: %s", network_error_string());
 * }
 *
 * // Accept connection with timeout
 * int client_fd = accept_with_timeout(listenfd, NULL, NULL, ACCEPT_TIMEOUT);
 * if (client_fd < 0) {
 *     log_error("Accept failed: %s", network_error_string());
 * }
 * @endcode
 *
 * @subsection network_packet_operations Packet Operations
 *
 * **Basic Packet I/O**:
 * @code{.c}
 * // Send a packet
 * asciichat_error_t err = packet_send(sockfd, PACKET_TYPE_PING, NULL, 0);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Packet send failed");
 * }
 *
 * // Receive a packet
 * packet_type_t type;
 * void *data;
 * size_t len;
 * err = packet_receive(sockfd, &type, &data, &len);
 * if (err == ASCIICHAT_OK) {
 *     // Process packet
 *     process_packet(type, data, len);
 *     free(data);  // Free allocated buffer
 * }
 * @endcode
 *
 * **Secure Packet I/O**:
 * @code{.c}
 * // Send encrypted packet
 * int result = send_packet_secure(sockfd, PACKET_TYPE_ASCII_FRAME,
 *                                  frame_data, frame_size, crypto_ctx);
 * if (result < 0) {
 *     log_error("Secure send failed");
 * }
 *
 * // Receive and decrypt packet
 * packet_envelope_t envelope;
 * packet_recv_result_t result = receive_packet_secure(sockfd, crypto_ctx,
 *                                                      true, &envelope);
 * if (result == PACKET_RECV_SUCCESS) {
 *     // Process decrypted packet
 *     process_packet(envelope.type, envelope.data, envelope.len);
 *     free(envelope.allocated_buffer);  // Free allocated buffer
 * }
 * @endcode
 *
 * @subsection network_socket_config Socket Configuration
 *
 * **Socket Setup**:
 * @code{.c}
 * // Set socket timeout
 * if (set_socket_timeout(sockfd, SEND_TIMEOUT) < 0) {
 *     log_error("Failed to set socket timeout");
 * }
 *
 * // Enable TCP keepalive
 * if (set_socket_keepalive(sockfd) < 0) {
 *     log_error("Failed to enable keepalive");
 * }
 *
 * // Set non-blocking mode
 * if (set_socket_nonblocking(sockfd) < 0) {
 *     log_error("Failed to set non-blocking mode");
 * }
 * @endcode
 *
 * @section network_integration Integration
 *
 * The Network I/O module integrates with:
 * - **platform/socket.h**: Uses platform socket abstraction
 * - **network/packet_types.h**: Packet type definitions
 * - **crypto/crypto.h**: Encryption/decryption operations
 * - **compression.h**: Compression/decompression support
 * - **network/av.h**: Media packet sending
 * - **crypto/handshake.h**: Crypto handshake operations
 *
 * @section network_performance Performance
 *
 * **Chunked Transmission**:
 * - Enables progressive sending of large frames
 * - Prevents timeout issues with large data
 * - Allows progress tracking
 *
 * **Timeout Handling**:
 * - Prevents indefinite blocking
 * - Tuned for real-time video streaming
 * - Platform-specific optimizations (select/poll/epoll)
 *
 * **Keepalive Settings**:
 * - Efficiently detects dead connections
 * - No application-level heartbeats required
 * - Configurable idle time and probe count
 *
 * @section network_error_handling Error Handling
 *
 * **Error Reporting**:
 * @code{.c}
 * // Get human-readable error string
 * const char *error_msg = network_error_string();
 * log_error("Network error: %s", error_msg);
 * @endcode
 *
 * **Error Codes**:
 * - Function return values: -1 indicates error
 * - asciichat_error_t codes: ASCIICHAT_OK on success, error codes on failure
 * - packet_recv_result_t codes: PACKET_RECV_SUCCESS, PACKET_RECV_EOF, etc.
 *
 * @section network_timeouts Timeout Configuration
 *
 * Timeout configuration is all about balance—too short and you get false positives
 * on slow networks, too long and you delay error detection unnecessarily. We've
 * tuned these values specifically for real-time video streaming.
 *
 * What timeouts do we use?
 * ------------------------
 * - **CONNECT_TIMEOUT** (3 seconds): Reduced from the default for faster connection
 *   attempts. If a connection doesn't work, we want to know quickly so we can try
 *   again or report the error
 * - **SEND_TIMEOUT** (5 seconds): This gives enough time for timely delivery of video
 *   frames. It's long enough that network hiccups don't cause false positives, but
 *   short enough that stuck sends are detected quickly
 * - **RECV_TIMEOUT** (15 seconds): This is longer than send timeout because network
 *   delays are more common on receive. We want to give the network time to deliver
 *   data, but not so much time that we hang forever
 * - **ACCEPT_TIMEOUT** (3 seconds): This is balanced between responsiveness (we don't
 *   want to waste CPU checking too often) and quick detection of problems
 *
 * ⚠️ Important timeout notes:
 * ----------------------------
 * Timeout values that are too short may cause false positives on slow networks—you
 * might think the connection is dead when it's just slow. Values that are too long
 * may delay error detection unnecessarily—you might wait too long before realizing
 * something is wrong.
 *
 * If you're running on a very slow network (like satellite internet), you might want
 * to increase these timeouts. If you're running on a very fast network (like a local
 * LAN), you could decrease them for faster error detection.
 *
 * @section network_chunked_transmission Chunked Transmission
 *
 * Large data transfers are automatically chunked—this is how we send big video frames
 * without blocking the connection. Instead of sending everything at once (which could
 * cause timeouts or block other operations), we break large data into smaller chunks.
 *
 * How does chunked transmission work?
 * -----------------------------------
 * - **Prevents timeout issues**: Large frames can be several megabytes—if we try to
 *   send it all at once, we might timeout before it finishes. Chunking lets us send
 *   the frame in pieces, so each piece can complete quickly
 * - **Enables progress tracking**: We can report progress as chunks are sent, so
 *   you know things are working even when sending large frames
 * - **Handles partial sends automatically**: Sometimes `send()` doesn't send everything
 *   you ask it to—chunking handles this gracefully by retrying until the chunk is sent
 * - **Retries until complete**: If a chunk fails to send, we retry until all data is
 *   sent or the timeout occurs
 *
 * This is used automatically for large data—you don't need to do anything special.
 * The system detects when data is large enough to benefit from chunking and handles
 * it automatically.
 *
 * @section network_packet_security Packet Security
 *
 * The packet protocol supports:
 * - **Encryption**: Automatic encryption/decryption when crypto context provided
 * - **Compression**: Automatic compression for large packets
 * - **Validation**: Magic number and CRC32 checksum verification
 * - **Policy Enforcement**: Encryption requirement enforcement
 *
 * **Handshake Packets**:
 * - Always sent unencrypted (plaintext)
 * - Use `packet_is_handshake_type()` to check before encryption
 * - Required for crypto handshake establishment
 *
 * @section network_best_practices Best Practices
 *
 * 1. **Always check return values**:
 *    @code{.c}
 *    if (send_with_timeout(sockfd, data, len, timeout) < 0) {
 *        // Handle error
 *    }
 *    @endcode
 *
 * 2. **Free allocated packet buffers**:
 *    @code{.c}
 *    void *data;
 *    size_t len;
 *    packet_receive(sockfd, &type, &data, &len);
 *    // ... use data ...
 *    free(data);  // Always free
 *    @endcode
 *
 * 3. **Use secure packet functions for encryption**:
 *    @code{.c}
 *    send_packet_secure(sockfd, type, data, len, crypto_ctx);
 *    receive_packet_secure(sockfd, crypto_ctx, true, &envelope);
 *    @endcode
 *
 * 4. **Enable keepalive for long-lived connections**:
 *    @code{.c}
 *    set_socket_keepalive(sockfd);
 *    @endcode
 *
 * 5. **Configure timeouts appropriately**:
 *    @code{.c}
 *    set_socket_timeout(sockfd, SEND_TIMEOUT);
 *    @endcode
 *
 * @see network/network.h
 * @see network/packet.h
 * @see network/packet_types.h
 */

