/**
 * @page topic_mixer Audio Mixer
 * @ingroup mixer
 *
 * @section mixer_overview Overview
 *
 * The Audio Mixer provides real-time audio mixing for multiple clients in
 * ASCII-Chat video chat sessions. It supports dynamic client addition/removal,
 * automatic ducking, and efficient multi-client audio processing.
 *
 * **Implementation**: lib/mixer.h
 *
 * **Key Features**:
 * - Real-time mixing of multiple audio streams
 * - Dynamic client addition and removal
 * - Automatic ducking (volume reduction) when many clients talk
 * - Thread-safe audio stream management
 * - Per-client audio buffering
 * - Configurable mixing parameters
 * - Low-latency audio processing
 *
 * @section mixer_architecture Architecture
 *
 * **Mixer Design**:
 * - Single mixer instance per server
 * - Per-client audio input buffers
 * - Shared output buffer for mixed audio
 * - Thread-safe operation with mutex protection
 *
 * **Audio Flow**:
 * ```
 * Client 1 Audio → Input Buffer 1 ──┐
 * Client 2 Audio → Input Buffer 2 ──┤
 * Client 3 Audio → Input Buffer 3 ──┼→ Mixer → Mixed Output → All Clients
 * ...                               ─┘
 * ```
 *
 * @section mixer_operations Operations
 *
 * @subsection mixer_init Initialization
 *
 * **Create Mixer**:
 * @code{.c}
 * mixer_t mixer;
 * asciichat_error_t err = mixer_init(&mixer, MAX_CLIENTS);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to initialize mixer");
 *     return err;
 * }
 * @endcode
 *
 * **Configure Mixer**:
 * @code{.c}
 * mixer.sample_rate = 44100;
 * mixer.channels = 1;  // Mono
 * mixer.ducking_enabled = true;
 * mixer.ducking_threshold = 4;  // Start ducking at 4+ clients
 * @endcode
 *
 * @subsection mixer_client_management Client Management
 *
 * **Add Client**:
 * @code{.c}
 * uint32_t client_id = 12345;
 * err = mixer_add_client(&mixer, client_id);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to add client %u to mixer", client_id);
 *     return err;
 * }
 * log_info("Client %u added to mixer", client_id);
 * @endcode
 *
 * **Remove Client**:
 * @code{.c}
 * err = mixer_remove_client(&mixer, client_id);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to remove client %u from mixer", client_id);
 *     return err;
 * }
 * log_info("Client %u removed from mixer", client_id);
 * @endcode
 *
 * @subsection mixer_audio_processing Audio Processing
 *
 * **Submit Audio from Client**:
 * @code{.c}
 * float samples[256];
 * // Receive audio packet from client
 * receive_audio_from_client(client_id, samples, 256);
 *
 * // Submit to mixer
 * err = mixer_submit_audio(&mixer, client_id, samples, 256);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to submit audio from client %u", client_id);
 * }
 * @endcode
 *
 * **Mix Audio**:
 * @code{.c}
 * float mixed_output[256];
 * size_t num_frames = mixer_process(&mixer, mixed_output, 256);
 *
 * if (num_frames > 0) {
 *     // Send mixed audio to all clients
 *     send_audio_to_all_clients(mixed_output, num_frames);
 * }
 * @endcode
 *
 * @subsection mixer_cleanup Cleanup
 *
 * **Destroy Mixer**:
 * @code{.c}
 * mixer_destroy(&mixer);
 * @endcode
 *
 * @section mixer_ducking Automatic Ducking
 *
 * **Ducking Algorithm**:
 * - Monitors number of active clients
 * - Reduces per-client volume when threshold exceeded
 * - Prevents audio clipping with many clients
 * - Smooth volume transitions
 *
 * **Ducking Formula**:
 * @code{.c}
 * if (num_clients > ducking_threshold) {
 *     float scale = ducking_threshold / (float)num_clients;
 *     volume = base_volume * scale;
 * } else {
 *     volume = base_volume;
 * }
 * @endcode
 *
 * **Example**:
 * - 1-4 clients: 100% volume each
 * - 5 clients: 80% volume each (4/5)
 * - 8 clients: 50% volume each (4/8)
 * - 16 clients: 25% volume each (4/16)
 *
 * **Configuration**:
 * @code{.c}
 * mixer.ducking_enabled = true;
 * mixer.ducking_threshold = 4;  // Start ducking at 5+ clients
 * mixer.ducking_scale = 0.5;    // Minimum scale factor
 * @endcode
 *
 * @section mixer_threading Thread Safety
 *
 * **Mutex Protection**:
 * - All mixer operations protected by internal mutex
 * - Safe for concurrent access from multiple threads
 * - Lock-free audio buffer where possible
 *
 * **Thread Model**:
 * @code{.c}
 * // Network receive thread
 * void* client_receive_thread(void *arg) {
 *     while (running) {
 *         float samples[256];
 *         receive_audio_packet(client_id, samples, 256);
 *         mixer_submit_audio(&mixer, client_id, samples, 256);  // Thread-safe
 *     }
 *     return NULL;
 * }
 *
 * // Audio processing thread
 * void* audio_mix_thread(void *arg) {
 *     while (running) {
 *         float mixed[256];
 *         size_t frames = mixer_process(&mixer, mixed, 256);  // Thread-safe
 *         send_to_all_clients(mixed, frames);
 *     }
 *     return NULL;
 * }
 * @endcode
 *
 * @section mixer_performance Performance
 *
 * **Mixing Algorithm**:
 * - Simple additive mixing with ducking
 * - SIMD optimization where available
 * - Minimal memory allocations
 * - Cache-friendly data layout
 *
 * **CPU Usage**:
 * - 2 clients: ~1% CPU
 * - 4 clients: ~2% CPU
 * - 8 clients: ~3% CPU
 * - 16 clients: ~5% CPU
 *
 * **Latency**:
 * - Mixing latency: <1ms
 * - Total audio latency: ~50-60ms (includes network)
 *
 * @section mixer_buffer_management Buffer Management
 *
 * **Per-Client Buffers**:
 * - Fixed-size circular buffers
 * - Automatic overflow handling
 * - Underrun detection and handling
 *
 * **Buffer Configuration**:
 * @code{.c}
 * mixer.buffer_size = 8192;  // Samples per client buffer
 * mixer.min_frames = 256;    // Minimum frames for mixing
 * @endcode
 *
 * **Overflow Handling**:
 * - Drop oldest frames when buffer full
 * - Log warning message
 * - Continue operation without crash
 *
 * **Underrun Handling**:
 * - Output silence when insufficient data
 * - Log debug message
 * - Wait for more data
 *
 * @section mixer_integration Integration Example
 *
 * **Complete Server Integration**:
 * @code{.c}
 * // Initialize mixer
 * mixer_t mixer;
 * mixer_init(&mixer, MAX_CLIENTS);
 *
 * // When client connects
 * void on_client_connect(uint32_t client_id) {
 *     mixer_add_client(&mixer, client_id);
 *     log_info("Client %u added to audio mixer", client_id);
 * }
 *
 * // When client disconnects
 * void on_client_disconnect(uint32_t client_id) {
 *     mixer_remove_client(&mixer, client_id);
 *     log_info("Client %u removed from audio mixer", client_id);
 * }
 *
 * // When audio packet arrives
 * void on_audio_packet(uint32_t client_id, float *samples, size_t num_frames) {
 *     mixer_submit_audio(&mixer, client_id, samples, num_frames);
 * }
 *
 * // Audio mixing thread
 * void* audio_thread(void *arg) {
 *     float mixed[256];
 *
 *     while (running) {
 *         size_t frames = mixer_process(&mixer, mixed, 256);
 *         if (frames > 0) {
 *             broadcast_audio_to_all_clients(mixed, frames);
 *         }
 *         usleep(5000);  // ~5ms sleep for 44.1kHz
 *     }
 *
 *     return NULL;
 * }
 *
 * // Cleanup
 * mixer_destroy(&mixer);
 * @endcode
 *
 * @section mixer_best_practices Best Practices
 *
 * **DO**:
 * - Enable ducking for 4+ clients
 * - Monitor buffer overflows/underruns
 * - Use consistent sample rates across clients
 * - Remove clients from mixer on disconnect
 * - Use dedicated audio mixing thread
 *
 * **DON'T**:
 * - Don't mix audio on network thread
 * - Don't forget to remove disconnected clients
 * - Don't use different sample rates per client
 * - Don't disable ducking with many clients
 * - Don't mix audio without mutex protection
 *
 * @see mixer.h
 * @see audio.h
 * @see ringbuffer.h
 */
