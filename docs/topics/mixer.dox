/**
 * @page topic_mixer Mixer README
 * @ingroup audio
 *
 * @section mixer_overview Overview
 *
 * Welcome to the audio mixer—where all the magic happens when multiple people are talking at once!
 *
 * Picture yourself in a group video call. Person A is talking, Person B laughs, Person C asks a
 * question—all happening simultaneously. Your speakers don't have three separate outputs (well,
 * most don't). So how does your computer play all three audio streams at once? That's where the
 * mixer comes in!
 *
 * The mixer takes multiple audio streams (one from each client) and combines them into a single
 * output stream that gets sent to everyone. It's like a real mixing board at a concert—each
 * microphone is a separate input, and the mixer blends them into one cohesive sound that goes
 * to the speakers.
 *
 * But here's the cool part: when lots of people are talking at once, the mixer automatically
 * applies "ducking" (volume reduction) so the combined audio doesn't clip or distort. It's like
 * how a good sound engineer knows to turn down each microphone a bit when everyone's singing
 * together—the mix stays clear and balanced.
 *
 * **Implementation**: lib/mixer.h
 *
 * What makes the mixer special?
 * ------------------------------
 * - **Real-time mixing**: Combines multiple audio streams on the fly
 * - **Dynamic client management**: Clients can join or leave without disrupting the mix
 * - **Automatic ducking**: Prevents distortion when many people talk simultaneously
 * - **Thread-safe**: Safe for multi-threaded audio processing
 * - **Low latency**: Minimal processing delay (you won't notice it!)
 * - **Per-client buffering**: Each client has their own buffer for smooth audio
 * @section mixer_architecture Architecture
 *
 * **Mixer Design**:
 * - Single mixer instance per server
 * - Per-client audio input buffers
 * - Shared output buffer for mixed audio
 * - Thread-safe operation with mutex protection
 *
 * **Audio Flow**:
 * ```
 * Client 1 Audio → Input Buffer 1 ──┐
 * Client 2 Audio → Input Buffer 2 ──┤
 * Client 3 Audio → Input Buffer 3 ──┼→ Mixer → Mixed Output → All Clients
 * ...                               ─┘
 * ```
 *
 * @section mixer_operations Operations
 *
 * @subsection mixer_init Initialization
 *
 * **Create Mixer**:
 * @code{.c}
 * mixer_t mixer;
 * asciichat_error_t err = mixer_init(&mixer, MAX_CLIENTS);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to initialize mixer");
 *     return err;
 * }
 * @endcode
 *
 * **Configure Mixer**:
 * @code{.c}
 * mixer.sample_rate = 44100;
 * mixer.channels = 1;  // Mono
 * mixer.ducking_enabled = true;
 * mixer.ducking_threshold = 4;  // Start ducking at 4+ clients
 * @endcode
 *
 * @subsection mixer_client_management Client Management
 *
 * **Add Client**:
 * @code{.c}
 * uint32_t client_id = 12345;
 * err = mixer_add_client(&mixer, client_id);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to add client %u to mixer", client_id);
 *     return err;
 * }
 * log_info("Client %u added to mixer", client_id);
 * @endcode
 *
 * **Remove Client**:
 * @code{.c}
 * err = mixer_remove_client(&mixer, client_id);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to remove client %u from mixer", client_id);
 *     return err;
 * }
 * log_info("Client %u removed from mixer", client_id);
 * @endcode
 *
 * @subsection mixer_audio_processing Audio Processing
 *
 * **Submit Audio from Client**:
 * @code{.c}
 * float samples[256];
 * // Receive audio packet from client
 * receive_audio_from_client(client_id, samples, 256);
 *
 * // Submit to mixer
 * err = mixer_submit_audio(&mixer, client_id, samples, 256);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to submit audio from client %u", client_id);
 * }
 * @endcode
 *
 * **Mix Audio**:
 * @code{.c}
 * float mixed_output[256];
 * size_t num_frames = mixer_process(&mixer, mixed_output, 256);
 *
 * if (num_frames > 0) {
 *     // Send mixed audio to all clients
 *     send_audio_to_all_clients(mixed_output, num_frames);
 * }
 * @endcode
 *
 * @subsection mixer_cleanup Cleanup
 *
 * **Destroy Mixer**:
 * @code{.c}
 * mixer_destroy(&mixer);
 * @endcode
 *
 * @section mixer_ducking Automatic Ducking
 *
 * Ducking is one of the mixer's coolest features. Here's the problem it solves: if you have
 * 8 people all talking at full volume, the mixed audio would be 8× louder—way too loud! You'd
 * get clipping, distortion, and generally terrible audio quality.
 *
 * The solution? Automatically reduce everyone's volume proportionally. The ducking algorithm
 * is beautifully simple:
 *
 * - **Monitor**: Keep track of how many clients are talking
 * - **Scale down**: When more than 4 clients talk, reduce each person's volume proportionally
 * - **Prevent clipping**: This keeps the mixed output from getting too loud
 * - **Smooth transitions**: Volume changes happen gradually (no jarring jumps)
 *
 * The math is straightforward:
 * @code{.c}
 * if (num_clients > ducking_threshold) {
 *     float scale = ducking_threshold / (float)num_clients;
 *     volume = base_volume * scale;
 * } else {
 *     volume = base_volume;
 * }
 * @endcode
 *
 * Here's what it looks like in practice:
 * - **1-4 clients**: 100% volume each (full volume, no ducking needed)
 * - **5 clients**: 80% volume each (4/5 = 0.8)
 * - **8 clients**: 50% volume each (4/8 = 0.5)
 * - **16 clients**: 25% volume each (4/16 = 0.25)
 *
 * Even with 16 people talking, everyone is still audible—just quieter individually so
 * the total mix stays at a reasonable level!
 *
 * **Configuration**:
 * @code{.c}
 * mixer.ducking_enabled = true;
 * mixer.ducking_threshold = 4;  // Start ducking at 5+ clients
 * mixer.ducking_scale = 0.5;    // Minimum scale factor
 * @endcode
 *
 * @section mixer_threading Thread Safety
 *
 * **Mutex Protection**:
 * - All mixer operations protected by internal mutex
 * - Safe for concurrent access from multiple threads
 * - Lock-free audio buffer where possible
 *
 * **Thread Model**:
 * @code{.c}
 * // Network receive thread
 * void* client_receive_thread(void *arg) {
 *     while (running) {
 *         float samples[256];
 *         receive_audio_packet(client_id, samples, 256);
 *         mixer_submit_audio(&mixer, client_id, samples, 256);  // Thread-safe
 *     }
 *     return NULL;
 * }
 *
 * // Audio processing thread
 * void* audio_mix_thread(void *arg) {
 *     while (running) {
 *         float mixed[256];
 *         size_t frames = mixer_process(&mixer, mixed, 256);  // Thread-safe
 *         send_to_all_clients(mixed, frames);
 *     }
 *     return NULL;
 * }
 * @endcode
 *
 * @section mixer_performance Performance
 *
 * **Mixing Algorithm**:
 * - Simple additive mixing with ducking
 * - SIMD optimization where available
 * - Minimal memory allocations
 * - Cache-friendly data layout
 *
 * **CPU Usage**:
 * - 2 clients: ~1% CPU
 * - 4 clients: ~2% CPU
 * - 8 clients: ~3% CPU
 * - 16 clients: ~5% CPU
 *
 * **Latency**:
 * - Mixing latency: <1ms
 * - Total audio latency: ~50-60ms (includes network)
 *
 * @section mixer_buffer_management Buffer Management
 *
 * **Per-Client Buffers**:
 * - Fixed-size circular buffers
 * - Automatic overflow handling
 * - Underrun detection and handling
 *
 * **Buffer Configuration**:
 * @code{.c}
 * mixer.buffer_size = 8192;  // Samples per client buffer
 * mixer.min_frames = 256;    // Minimum frames for mixing
 * @endcode
 *
 * **Overflow Handling**:
 * - Drop oldest frames when buffer full
 * - Log warning message
 * - Continue operation without crash
 *
 * **Underrun Handling**:
 * - Output silence when insufficient data
 * - Log debug message
 * - Wait for more data
 *
 * @section mixer_integration Integration Example
 *
 * **Complete Server Integration**:
 * @code{.c}
 * // Initialize mixer
 * mixer_t mixer;
 * mixer_init(&mixer, MAX_CLIENTS);
 *
 * // When client connects
 * void on_client_connect(uint32_t client_id) {
 *     mixer_add_client(&mixer, client_id);
 *     log_info("Client %u added to audio mixer", client_id);
 * }
 *
 * // When client disconnects
 * void on_client_disconnect(uint32_t client_id) {
 *     mixer_remove_client(&mixer, client_id);
 *     log_info("Client %u removed from audio mixer", client_id);
 * }
 *
 * // When audio packet arrives
 * void on_audio_packet(uint32_t client_id, float *samples, size_t num_frames) {
 *     mixer_submit_audio(&mixer, client_id, samples, num_frames);
 * }
 *
 * // Audio mixing thread
 * void* audio_thread(void *arg) {
 *     float mixed[256];
 *
 *     while (running) {
 *         size_t frames = mixer_process(&mixer, mixed, 256);
 *         if (frames > 0) {
 *             broadcast_audio_to_all_clients(mixed, frames);
 *         }
 *         usleep(5000);  // ~5ms sleep for 44.1kHz
 *     }
 *
 *     return NULL;
 * }
 *
 * // Cleanup
 * mixer_destroy(&mixer);
 * @endcode
 *
 * @section mixer_best_practices Best Practices
 *
 * **DO**:
 * - Enable ducking for 4+ clients
 * - Monitor buffer overflows/underruns
 * - Use consistent sample rates across clients
 * - Remove clients from mixer on disconnect
 * - Use dedicated audio mixing thread
 *
 * **DON'T**:
 * - Don't mix audio on network thread
 * - Don't forget to remove disconnected clients
 * - Don't use different sample rates per client
 * - Don't disable ducking with many clients
 * - Don't mix audio without mutex protection
 *
 * @see mixer.h
 * @see audio.h
 * @see ringbuffer.h
 */
