/**
 * @page topic_common Common Definitions
 * @ingroup common
 *
 * Core error handling, memory management, logging, and type definitions shared throughout
 * the ascii-chat application.
 *
 * @section common_overview Overview
 *
 * The common module (lib/common.h, lib/common.c) provides fundamental infrastructure:
 * - Comprehensive error handling with context tracking
 * - Memory allocation with leak detection in debug builds
 * - Rate-limited logging for high-frequency code paths
 * - Platform-independent type definitions
 * - Shared constants and macros
 *
 * All application code should use these common definitions to ensure consistency,
 * proper error handling, and debuggability.
 *
 * @section common_errors Error Handling System
 *
 * ascii-chat uses a comprehensive error system (lib/asciichat_errno.h) that provides:
 * - Specific error codes for different failure modes
 * - Contextual error messages with file/line/function information
 * - System error integration (errno on POSIX, GetLastError on Windows)
 * - Thread-local error state (thread-safe)
 * - Stack traces in debug builds
 *
 * @subsection common_error_codes Error Code Enumeration
 *
 * @code{.c}
 * typedef enum {
 *     // Standard codes (0-2) - Unix conventions
 *     ASCIICHAT_OK = 0,                   // Success
 *     ERROR_GENERAL = 1,                  // Unspecified error
 *     ERROR_USAGE = 2,                    // Invalid command line arguments
 *
 *     // Initialization failures (3-19)
 *     ERROR_MEMORY = 3,                   // Memory allocation failed (OOM)
 *     ERROR_CONFIG = 4,                   // Configuration file or settings error
 *     ERROR_CRYPTO_INIT = 5,              // Cryptographic initialization failed
 *     ERROR_LOGGING_INIT = 6,             // Logging system initialization failed
 *     ERROR_PLATFORM_INIT = 7,            // Platform-specific initialization failed
 *
 *     // Hardware/Device errors (20-39)
 *     ERROR_WEBCAM = 20,                  // Webcam initialization or capture failed
 *     ERROR_WEBCAM_IN_USE = 21,           // Webcam is in use by another application
 *     ERROR_WEBCAM_PERMISSION = 22,       // Webcam permission denied
 *     ERROR_AUDIO = 23,                   // Audio device initialization or I/O failed
 *     ERROR_AUDIO_IN_USE = 24,            // Audio device is in use
 *     ERROR_TERMINAL = 25,                // Terminal initialization failed
 *
 *     // Network errors (40-59)
 *     ERROR_NETWORK = 40,                 // General network error
 *     ERROR_NETWORK_BIND = 41,            // Cannot bind to port (server)
 *     ERROR_NETWORK_CONNECT = 42,         // Cannot connect to server (client)
 *     ERROR_NETWORK_TIMEOUT = 43,         // Network operation timed out
 *     ERROR_NETWORK_PROTOCOL = 44,        // Protocol violation or incompatible version
 *     ERROR_NETWORK_SIZE = 45,            // Network packet size error
 *
 *     // Security/Crypto errors (60-79)
 *     ERROR_CRYPTO = 60,                  // Cryptographic operation failed
 *     ERROR_CRYPTO_KEY = 61,              // Key loading, parsing, or generation failed
 *     ERROR_CRYPTO_AUTH = 62,             // Authentication failed
 *     ERROR_CRYPTO_HANDSHAKE = 63,        // Cryptographic handshake failed
 *     ERROR_CRYPTO_VERIFICATION = 64,     // Signature or key verification failed
 *
 *     // Runtime errors (80-99)
 *     ERROR_THREAD = 80,                  // Thread creation or management failed
 *     ERROR_BUFFER = 81,                  // Buffer allocation or overflow
 *     ERROR_BUFFER_FULL = 82,             // Buffer full
 *     ERROR_BUFFER_OVERFLOW = 83,         // Buffer overflow
 *     ERROR_DISPLAY = 84,                 // Display rendering or output error
 *     ERROR_INVALID_STATE = 85,           // Invalid program state
 *     ERROR_INVALID_PARAM = 86,           // Invalid parameter
 *     ERROR_INVALID_FRAME = 87,           // Invalid frame data
 *     ERROR_RESOURCE_EXHAUSTED = 88,      // System resources exhausted
 *     ERROR_FORMAT = 89,                  // String formatting operation failed
 *     ERROR_STRING = 90,                  // String manipulation operation failed
 *
 *     // Signal/Crash handlers (100-127)
 *     ERROR_SIGNAL_INTERRUPT = 100,       // Interrupted by signal (SIGINT, SIGTERM)
 *     ERROR_SIGNAL_CRASH = 101,           // Fatal signal (SIGSEGV, SIGABRT, etc.)
 *     ERROR_ASSERTION_FAILED = 102,       // Assertion or invariant violation
 *
 *     // Compression errors (103-104)
 *     ERROR_COMPRESSION = 103,            // Compression operation failed
 *     ERROR_DECOMPRESSION = 104,          // Decompression operation failed
 * } asciichat_error_t;
 * @endcode
 *
 * @subsection common_error_context Error Context
 *
 * Each error includes rich contextual information:
 *
 * @code{.c}
 * typedef struct {
 *     asciichat_error_t code;     // Error code (asciichat_error_t enum value)
 *     const char *file;           // Source file where error occurred (NULL in release)
 *     int line;                   // Line number where error occurred (0 in release)
 *     const char *function;       // Function name where error occurred (NULL in release)
 *     char *context_message;      // Optional custom message (dynamically allocated)
 *     uint64_t timestamp;         // Timestamp when error occurred (microseconds)
 *     int system_errno;           // System errno value (if applicable, 0 otherwise)
 *     int wsa_error;              // Windows socket error code (if applicable)
 *     void *backtrace[32];        // Stack trace addresses (debug builds only)
 *     char **backtrace_symbols;   // Stack trace symbol strings (debug builds only)
 *     int stack_depth;            // Number of stack frames captured
 *     bool has_system_error;      // True if system_errno is valid
 *     bool has_wsa_error;         // True if wsa_error is valid
 * } asciichat_error_context_t;
 * @endcode
 *
 * @subsection common_error_macros Error Handling Macros
 *
 * **SET_ERRNO**: Set error with custom message
 * @code{.c}
 * asciichat_error_t open_file(const char *path) {
 *     if (!path) {
 *         return SET_ERRNO(ERROR_INVALID_PARAM, "File path is NULL");
 *     }
 *
 *     int fd = open(path, O_RDONLY);
 *     if (fd < 0) {
 *         return SET_ERRNO_SYS(ERROR_NOT_FOUND, "Failed to open file: %s", path);
 *     }
 *
 *     return ASCIICHAT_OK;
 * }
 * @endcode
 *
 * **SET_ERRNO_SYS**: Set error with system errno
 * @code{.c}
 * asciichat_error_t create_socket(void) {
 *     socket_t sockfd = socket(AF_INET6, SOCK_STREAM, 0);
 *     if (sockfd == INVALID_SOCKET_VALUE) {
 *         return SET_ERRNO_SYS(ERROR_NETWORK_SOCKET,
 *                               "socket() failed (errno=%d)", errno);
 *     }
 *     return ASCIICHAT_OK;
 * }
 * @endcode
 *
 * **HAS_ERRNO**: Check if error occurred
 * @code{.c}
 * asciichat_error_context_t err_ctx;
 * asciichat_error_t result = risky_operation();
 * if (HAS_ERRNO(&err_ctx)) {
 *     log_error("Operation failed: %s (code=%d, file=%s:%d)",
 *               err_ctx.context_message, err_ctx.error_code,
 *               err_ctx.file, err_ctx.line);
 *     return result;
 * }
 * @endcode
 *
 * **PRINT_ERRNO_CONTEXT**: Debug print error details
 * @code{.c}
 * if (HAS_ERRNO(&err_ctx)) {
 *     PRINT_ERRNO_CONTEXT(&err_ctx);  // Only in debug builds
 *     // Output:
 *     // Error: ERROR_NETWORK_CONNECT (code=13)
 *     // Message: Failed to connect to server (Connection refused)
 *     // Location: src/client.c:245 in connect_to_server()
 *     // System errno: 111 (Connection refused)
 *     // Timestamp: 1234567890123456 µs
 * }
 * @endcode
 *
 * **CLEAR_ERRNO**: Clear error state
 * @code{.c}
 * CLEAR_ERRNO();  // Resets thread-local error state
 * @endcode
 *
 * **GET_ERRNO**: Get current error code
 * @code{.c}
 * asciichat_error_t current_error = GET_ERRNO();
 * if (current_error != ASCIICHAT_OK) {
 *     // Handle error
 * }
 * @endcode
 *
 * @section common_memory Memory Management
 *
 * Custom memory allocation macros with automatic leak detection in debug builds:
 *
 * @subsection common_memory_macros Memory Allocation Macros
 *
 * **SAFE_MALLOC**: Allocate memory with leak tracking
 * @code{.c}
 * // Syntax: SAFE_MALLOC(size, cast_type)
 * uint8_t *buffer = SAFE_MALLOC(1024, uint8_t*);
 * if (!buffer) {
 *     return SET_ERRNO(ERROR_MEMORY, "Failed to allocate 1024 bytes");
 * }
 *
 * // In debug builds, records:
 * // - Allocation address
 * // - Size (1024 bytes)
 * // - File (src/client.c)
 * // - Line (123)
 * // - Thread ID
 * @endcode
 *
 * **SAFE_CALLOC**: Allocate zeroed memory
 * @code{.c}
 * // Allocate array of 100 integers, initialized to 0
 * int *array = SAFE_CALLOC(100, sizeof(int), int*);
 * if (!array) {
 *     return ERROR_MEMORY;
 * }
 * @endcode
 *
 * **SAFE_REALLOC**: Reallocate memory
 * @code{.c}
 * // Grow buffer from 1024 to 2048 bytes
 * uint8_t *new_buffer = SAFE_REALLOC(buffer, 2048, uint8_t*);
 * if (!new_buffer) {
 *     // Original buffer still valid
 *     SAFE_FREE(buffer);
 *     return ERROR_MEMORY;
 * }
 * buffer = new_buffer;
 * @endcode
 *
 * **SAFE_FREE**: Free memory and set to NULL
 * @code{.c}
 * SAFE_FREE(buffer);  // Frees and sets buffer = NULL
 * // In debug builds, removes from leak tracker
 * @endcode
 *
 * @subsection common_memory_debug Debug Memory Tracking
 *
 * When CMAKE_BUILD_TYPE=Debug and DEBUG_MEMORY is defined:
 *
 * **Leak Detection**:
 * - All SAFE_MALLOC/CALLOC/REALLOC calls are recorded
 * - Each allocation stores: address, size, file, line, timestamp
 * - On program exit, reports any allocations not freed
 * - Example output:
 * @code
 * Memory leak detected:
 *   Address: 0x7f1234567890
 *   Size: 1024 bytes
 *   Allocated at: src/client.c:123 in process_frame()
 *   Thread: 0x7f123456
 * Total leaked: 1024 bytes in 1 allocation
 * @endcode
 *
 * **Allocation Logging**:
 * @code{.c}
 * #define DEBUG_MEMORY 1
 *
 * // Every allocation is logged:
 * // [MEMORY] malloc(1024) = 0x7f1234567890 at src/client.c:123
 * // [MEMORY] free(0x7f1234567890) at src/client.c:456
 * @endcode
 *
 * **Double-Free Detection**:
 * - Freeing already-freed memory triggers assertion
 * - Prevents use-after-free bugs
 *
 * **Memory Reports**:
 * @code{.c}
 * void asciichat_common_print_memory_stats(void);
 * // Prints:
 * // Current allocations: 5 (total 4096 bytes)
 * // Peak allocations: 10 (total 8192 bytes)
 * // Total malloc calls: 100
 * // Total free calls: 95
 * @endcode
 *
 * @section common_logging Logging System
 *
 * Multi-level logging with rate limiting for high-frequency code:
 *
 * @subsection common_logging_levels Log Levels
 *
 * @code{.c}
 * typedef enum {
 *     LOG_DEBUG = 0,   // Verbose debug information
 *     LOG_INFO = 1,    // Informational messages
 *     LOG_WARN = 2,    // Warnings (non-fatal issues)
 *     LOG_ERROR = 3,   // Errors (operation failed)
 *     LOG_FATAL = 4,   // Fatal errors (program will exit)
 * } log_level_t;
 * @endcode
 *
 * **Control via environment**:
 * @code{.bash}
 * export LOG_LEVEL=0  # DEBUG (all messages)
 * export LOG_LEVEL=1  # INFO and above
 * export LOG_LEVEL=2  # WARN and above
 * export LOG_LEVEL=3  # ERROR and above
 * export LOG_LEVEL=4  # FATAL only
 * @endcode
 *
 * @subsection common_logging_standard Standard Logging Macros
 *
 * @code{.c}
 * log_debug("Frame captured: %dx%d", width, height);
 * log_info("Client connected from %s:%d", ip, port);
 * log_warn("Audio buffer underrun detected");
 * log_error("Failed to send packet: %s", strerror(errno));
 * log_fatal("Critical error, terminating");  // Exits program
 * @endcode
 *
 * Output format:
 * @code
 * [2025-01-15 14:32:45.123] [DEBUG] Frame captured: 1920x1080
 * [2025-01-15 14:32:45.456] [INFO] Client connected from 192.168.1.100:12345
 * [2025-01-15 14:32:45.789] [WARN] Audio buffer underrun detected
 * [2025-01-15 14:32:46.012] [ERROR] Failed to send packet: Broken pipe
 * [2025-01-15 14:32:46.345] [FATAL] Critical error, terminating
 * @endcode
 *
 * @subsection common_logging_ratelimit Rate-Limited Logging
 *
 * For high-frequency code paths (e.g., video/audio processing at 60+ FPS):
 *
 * @code{.c}
 * // Log at most once per second (1000000 µs)
 * log_debug_every(1000000, "Processing frame %d", frame_count);
 *
 * // Log at most once per 5 seconds
 * log_info_every(5000000, "Client status: %d connected", num_clients);
 *
 * // Log at most once per 10 seconds
 * log_warn_every(10000000, "High CPU usage: %.1f%%", cpu_usage);
 * @endcode
 *
 * **Implementation**:
 * - Uses thread-local timestamp tracking
 * - First call always logs
 * - Subsequent calls within interval are suppressed
 * - Different log sites have independent rate limiting
 *
 * **Example** (video processing loop at 60 FPS):
 * @code{.c}
 * while (running) {
 *     capture_frame();
 *
 *     // Without rate limiting: 60 log messages per second
 *     // log_debug("Frame captured");
 *
 *     // With rate limiting: 1 log message per second
 *     log_debug_every(1000000, "Frame captured (count=%d)", frame_count);
 *
 *     frame_count++;
 * }
 * @endcode
 *
 * @subsection common_logging_config Logging Configuration
 *
 * @code{.c}
 * // Initialize logging system
 * asciichat_error_t log_init(const char *log_file, log_level_t level);
 *
 * // Change log level at runtime
 * void log_set_level(log_level_t level);
 *
 * // Enable/disable color output
 * void log_set_color(bool enable);
 *
 * // Cleanup logging
 * void log_destroy(void);
 * @endcode
 *
 * Usage:
 * @code{.c}
 * // Log to file and stderr
 * log_init("/tmp/ascii-chat.log", LOG_INFO);
 *
 * // Later: increase verbosity
 * log_set_level(LOG_DEBUG);
 *
 * // Cleanup
 * log_destroy();
 * @endcode
 *
 * @section common_types Common Type Definitions
 *
 * **Fixed-width integers** (platform-independent):
 * @code{.c}
 * #include <stdint.h>
 * int8_t, uint8_t      // 8-bit signed/unsigned
 * int16_t, uint16_t    // 16-bit signed/unsigned
 * int32_t, uint32_t    // 32-bit signed/unsigned
 * int64_t, uint64_t    // 64-bit signed/unsigned
 * size_t               // Unsigned size type (32 or 64-bit)
 * ssize_t              // Signed size type
 * @endcode
 *
 * **Boolean** (C99 style):
 * @code{.c}
 * #include <stdbool.h>
 * bool, true, false
 * @endcode
 *
 * **NULL pointer**:
 * @code{.c}
 * #define NULL ((void*)0)
 * @endcode
 *
 * @section common_constants Common Constants
 *
 * @code{.c}
 * // Buffer sizes
 * #define MAX_PACKET_SIZE 65536         // Maximum network packet payload
 * #define MAX_PATH_LEN 4096             // Maximum path length
 * #define MAX_CLIENTS 9                 // Maximum simultaneous clients
 *
 * // Network
 * #define DEFAULT_PORT 27224            // Default server port
 * #define PACKET_MAGIC 0xDEADBEEF      // Packet header magic number
 *
 * // Video
 * #define DEFAULT_WIDTH 80              // Default terminal width
 * #define DEFAULT_HEIGHT 24             // Default terminal height
 * #define DEFAULT_FPS 30                // Default framerate
 *
 * // Audio
 * #define SAMPLE_RATE 48000             // Audio sample rate (Hz)
 * #define AUDIO_CHANNELS 1              // Mono audio
 * #define FRAMES_PER_BUFFER 512         // PortAudio buffer size
 * @endcode
 *
 * @section common_usage Usage Examples
 *
 * @subsection common_usage_error Comprehensive Error Handling
 * @code{.c}
 * asciichat_error_t initialize_system(const char *config_file) {
 *     asciichat_error_t err;
 *
 *     // Load configuration
 *     options_t opts;
 *     err = config_load(&opts, config_file);
 *     if (err != ASCIICHAT_OK) {
 *         asciichat_error_context_t ctx;
 *         if (HAS_ERRNO(&ctx)) {
 *             log_error("Config load failed: %s", ctx.context_message);
 *             PRINT_ERRNO_CONTEXT(&ctx);
 *         }
 *         return err;
 *     }
 *
 *     // Initialize crypto
 *     crypto_context_t crypto_ctx;
 *     err = crypto_init(&crypto_ctx);
 *     if (err != ASCIICHAT_OK) {
 *         options_destroy(&opts);
 *         return err;
 *     }
 *
 *     // Initialize audio
 *     audio_context_t audio_ctx;
 *     err = audio_init(&audio_ctx);
 *     if (err != ASCIICHAT_OK) {
 *         crypto_destroy(&crypto_ctx);
 *         options_destroy(&opts);
 *         return err;
 *     }
 *
 *     return ASCIICHAT_OK;
 * }
 * @endcode
 *
 * @subsection common_usage_memory Memory Management with Leak Detection
 * @code{.c}
 * void process_data(void) {
 *     // Allocate buffers
 *     uint8_t *buffer1 = SAFE_MALLOC(1024, uint8_t*);
 *     uint8_t *buffer2 = SAFE_CALLOC(512, sizeof(uint8_t), uint8_t*);
 *
 *     if (!buffer1 || !buffer2) {
 *         log_error("Memory allocation failed");
 *         SAFE_FREE(buffer1);
 *         SAFE_FREE(buffer2);
 *         return;
 *     }
 *
 *     // Process data...
 *
 *     // Grow buffer if needed
 *     if (need_more_space) {
 *         uint8_t *new_buffer = SAFE_REALLOC(buffer1, 2048, uint8_t*);
 *         if (!new_buffer) {
 *             log_error("Reallocation failed");
 *             SAFE_FREE(buffer1);
 *             SAFE_FREE(buffer2);
 *             return;
 *         }
 *         buffer1 = new_buffer;
 *     }
 *
 *     // Cleanup (SAFE_FREE sets pointers to NULL)
 *     SAFE_FREE(buffer1);
 *     SAFE_FREE(buffer2);
 * }
 *
 * // At program exit (debug builds):
 * // If any SAFE_MALLOC'd memory wasn't freed, it's reported:
 * // Memory leak detected:
 * //   Address: 0x7f1234567890
 * //   Size: 1024 bytes
 * //   Allocated at: src/client.c:123
 * @endcode
 *
 * @subsection common_usage_logging Rate-Limited Logging in Video Loop
 * @code{.c}
 * void video_processing_loop(void) {
 *     uint64_t frame_count = 0;
 *     uint64_t dropped_frames = 0;
 *
 *     while (running) {
 *         // Capture frame (60 FPS)
 *         uint8_t *frame_data;
 *         asciichat_error_t err = webcam_capture_frame(webcam, &frame_data, &frame_len);
 *
 *         if (err != ASCIICHAT_OK) {
 *             dropped_frames++;
 *             // Log at most once per second to avoid spam
 *             log_warn_every(1000000, "Frame capture failed (dropped %lu frames)",
 *                             dropped_frames);
 *             continue;
 *         }
 *
 *         // Process frame...
 *
 *         frame_count++;
 *
 *         // Log progress every 5 seconds
 *         log_info_every(5000000, "Processed %lu frames (%.1f FPS)",
 *                         frame_count, calculate_fps());
 *     }
 * }
 * @endcode
 *
 * @see common.h
 * @see asciichat_errno.h
 * @see logging.h
 */
