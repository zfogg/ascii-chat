/**
 * @page topic_crypto Cryptography Module
 * @ingroup crypto
 *
 * The cryptography module provides end-to-end encryption for all ASCII-Chat communications
 * using libsodium, implementing a robust protocol with mutual authentication and perfect
 * forward secrecy.
 *
 * For comprehensive documentation on cryptographic implementation, threat models,
 * security considerations, and known vulnerabilities, see @ref topic_crypto_detailed
 * "Cryptography Detailed Documentation".
 *
 * @subpage topic_crypto_detailed
 *
 * @section crypto_overview Overview
 *
 * ASCII-Chat uses modern elliptic curve cryptography to provide:
 * - Confidentiality: XSalsa20-Poly1305 authenticated encryption
 * - Integrity: Built-in MAC (Message Authentication Code) verification
 * - Authenticity: Ed25519 digital signatures for identity verification
 * - Forward secrecy: Ephemeral X25519 key exchange per session
 * - Key agreement: Diffie-Hellman key exchange over Curve25519
 *
 * All cryptographic operations are handled by libsodium, providing:
 * - Constant-time operations (resistant to timing attacks)
 * - Automatic nonce management (prevents nonce reuse)
 * - Memory protection (zeroing sensitive data after use)
 * - Side-channel attack resistance
 *
 * @section crypto_algorithms Cryptographic Algorithms
 *
 * @subsection crypto_algo_x25519 X25519 (Curve25519)
 * Elliptic curve Diffie-Hellman (ECDH) key exchange:
 * - 128-bit security level
 * - Fast key generation (~30,000 operations/second)
 * - Small key size (32 bytes public, 32 bytes private)
 * - Safe-by-default design (no invalid curve points)
 * - Used for: Establishing shared secrets between client and server
 *
 * @subsection crypto_algo_xsalsa20 XSalsa20-Poly1305
 * Authenticated encryption with associated data (AEAD):
 * - XSalsa20: Stream cipher with 256-bit key, 192-bit nonce
 * - Poly1305: 128-bit MAC for authentication
 * - High performance: ~1 GB/s encryption on modern CPUs
 * - Nonce misuse resistance: 192-bit nonce space prevents collisions
 * - Used for: Encrypting all packet payloads after handshake
 *
 * @subsection crypto_algo_ed25519 Ed25519
 * Edwards-curve digital signature algorithm:
 * - 128-bit security level
 * - Deterministic signatures (no random number generation needed)
 * - Fast verification (~70,000 verifications/second)
 * - Small signatures (64 bytes)
 * - Used for: SSH key authentication and identity proof
 *
 * @subsection crypto_algo_blake2b Blake2b
 * Cryptographic hash function:
 * - Faster than SHA-3, SHA-2, and MD5
 * - Configurable output length (up to 64 bytes)
 * - Built-in keying for MAC operations
 * - Used for: Key derivation and known hosts verification
 *
 * @section crypto_architecture Architecture
 *
 * @subsection crypto_core Core Cryptographic Operations
 *
 * The crypto core (lib/crypto/crypto.c) provides:
 *
 * **Key Generation**:
 * - crypto_generate_keypair(): Creates ephemeral X25519 keypair
 * - Generates 32 bytes of random data for private key
 * - Derives public key via scalar multiplication on Curve25519
 * - Keys are single-use per connection (perfect forward secrecy)
 *
 * **Encryption**:
 * - crypto_encrypt(): Encrypts data with XSalsa20-Poly1305
 * - Automatically increments nonce counter (monotonic, never reused)
 * - Adds 16-byte MAC tag for authentication
 * - Returns ciphertext with embedded MAC
 *
 * **Decryption**:
 * - crypto_decrypt(): Decrypts and verifies MAC
 * - Checks nonce sequence to prevent replay attacks
 * - Constant-time MAC verification (timing attack resistant)
 * - Fails safely if MAC verification fails
 *
 * **Session Key Derivation**:
 * - Computes ECDH shared secret from keypairs
 * - Derives encryption/decryption keys using Blake2b
 * - Separate send/receive keys for bidirectional security
 * - Keys are 256 bits for XSalsa20
 *
 * @subsection crypto_handshake Handshake Protocol
 *
 * The handshake (lib/crypto/handshake.c) implements mutual authentication:
 *
 * **Phase 1: Key Exchange**
 * - Client generates ephemeral X25519 keypair
 * - Server generates ephemeral X25519 keypair
 * - Both parties exchange public keys over TCP
 * - Both compute same shared secret via ECDH
 *
 * **Phase 2: Server Authentication**
 * - Server creates challenge message with timestamp
 * - Server signs challenge with Ed25519 identity key
 * - Client verifies signature against known server key
 * - Client checks known_hosts file for TOFU verification
 *
 * **Phase 3: Client Authentication**
 * - Client creates response with server's challenge
 * - Client signs response with Ed25519 identity key
 * - Server verifies signature against authorized keys
 * - Server checks client key whitelist (if configured)
 *
 * **Phase 4: Session Establishment**
 * - Server sends confirmation message
 * - Both parties derive session encryption keys
 * - All subsequent packets are encrypted
 *
 * @subsection crypto_keys Key Management
 *
 * Key loading and validation (lib/crypto/keys/):
 *
 * **SSH Key Support** (lib/crypto/keys/ssh_keys.c):
 * - Loads OpenSSH Ed25519 private keys (~/.ssh/id_ed25519)
 * - Parses OpenSSH public key format
 * - Supports encrypted keys with PEM passphrase
 * - Validates key format and length
 * - Extracts 32-byte Ed25519 public/private keys
 *
 * **PEM Utilities** (lib/crypto/pem_utils.c):
 * - Decodes PEM-encoded private keys
 * - Handles "BEGIN OPENSSH PRIVATE KEY" format
 * - Decrypts encrypted keys using AES-256-CBC
 * - Base64 decoding for PEM data
 * - KDF for passphrase-based key derivation
 *
 * **SSH Agent Integration** (lib/crypto/ssh_agent.c):
 * - Connects to SSH agent via $SSH_AUTH_SOCK
 * - Lists available keys from agent
 * - Requests signatures without exposing private key
 * - Enables password-free authentication
 * - Falls back to password prompt if agent unavailable
 *
 * **HTTPS Key Fetching** (lib/crypto/keys/https_keys.c):
 * - Fetches public keys from GitHub API (github.com/username.keys)
 * - Fetches public keys from GitLab API
 * - Uses BearSSL for HTTPS connections
 * - Validates TLS certificates
 * - Parses SSH authorized_keys format
 * - Example: --client-keys github:alice
 *
 * **GPG Support** (lib/crypto/keys/gpg_keys.c):
 * - Loads GPG public keys
 * - Extracts Ed25519 subkeys from GPG keyring
 * - Supports GPG key export format
 * - Validates GPG key signatures
 *
 * **Known Hosts** (lib/crypto/known_hosts.c):
 * - TOFU (Trust On First Use) verification
 * - Stores server public keys by IP address
 * - Detects MITM attacks on subsequent connections
 * - Format: IP_address public_key timestamp
 * - Stored in ~/.config/ascii-chat/known_hosts
 *
 * @section crypto_usage Usage Examples
 *
 * @subsection crypto_usage_basic Basic Encryption
 * @code{.c}
 * // Initialize crypto context
 * crypto_context_t ctx;
 * asciichat_error_t err = crypto_init(&ctx);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to initialize crypto");
 *     return err;
 * }
 *
 * // Generate ephemeral keypair
 * uint8_t public_key[32];
 * uint8_t secret_key[32];
 * crypto_generate_keypair(public_key, secret_key);
 *
 * // Perform handshake
 * err = crypto_handshake_client(&ctx, sockfd, public_key, secret_key, NULL);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Handshake failed");
 *     crypto_destroy(&ctx);
 *     return err;
 * }
 *
 * // Encrypt data
 * const uint8_t plaintext[] = "Hello, secure world!";
 * uint8_t ciphertext[sizeof(plaintext) + crypto_box_MACBYTES];
 * size_t ciphertext_len;
 * err = crypto_encrypt(&ctx, plaintext, sizeof(plaintext), ciphertext, &ciphertext_len);
 *
 * // Decrypt data
 * uint8_t decrypted[sizeof(plaintext)];
 * size_t decrypted_len;
 * err = crypto_decrypt(&ctx, ciphertext, ciphertext_len, decrypted, &decrypted_len);
 *
 * // Cleanup (zeros all keys)
 * crypto_destroy(&ctx);
 * @endcode
 *
 * @subsection crypto_usage_keys Loading SSH Keys
 * @code{.c}
 * // Load SSH key from file
 * ed25519_key_t key;
 * const char *password = getenv("ASCII_CHAT_SSH_PASSWORD");
 * err = load_ssh_key("~/.ssh/id_ed25519", &key, password);
 * if (err != ASCIICHAT_OK) {
 *     log_error("Failed to load SSH key");
 *     return err;
 * }
 *
 * // Use key for authentication
 * err = crypto_handshake_client(&ctx, sockfd, key.public_key, key.secret_key, NULL);
 *
 * // Zero key data after use
 * sodium_memzero(&key, sizeof(key));
 * @endcode
 *
 * @subsection crypto_usage_agent SSH Agent Authentication
 * @code{.c}
 * // Connect to SSH agent
 * ssh_agent_context_t agent_ctx;
 * err = ssh_agent_connect(&agent_ctx);
 * if (err == ASCIICHAT_OK) {
 *     // List available keys
 *     ed25519_key_t *keys;
 *     size_t num_keys;
 *     err = ssh_agent_list_keys(&agent_ctx, &keys, &num_keys);
 *
 *     // Sign data with first key (agent holds private key)
 *     uint8_t signature[64];
 *     err = ssh_agent_sign(&agent_ctx, keys[0].public_key, data, data_len, signature);
 *
 *     ssh_agent_disconnect(&agent_ctx);
 * }
 * @endcode
 *
 * @section crypto_security Security Considerations
 *
 * **Key Management**:
 * - Private keys are zeroed with sodium_memzero() after use
 * - Keys are never written to disk unencrypted
 * - Encrypted keys use strong KDF (bcrypt/scrypt equivalent)
 * - SSH agent keeps private keys isolated in separate process
 *
 * **Nonce Management**:
 * - 192-bit nonces prevent birthday collisions (2^96 messages)
 * - Monotonic counter ensures nonces never repeat
 * - Counter overflow causes session termination (requires new handshake)
 * - Each direction (send/receive) has independent nonce counter
 *
 * **Session Security**:
 * - Ephemeral X25519 keys provide perfect forward secrecy
 * - Compromising long-term identity key doesn't reveal past sessions
 * - Each connection gets fresh random keys
 * - Session keys derived from both parties' contributions (no single point of control)
 *
 * **Authentication**:
 * - Known hosts file prevents MITM on subsequent connections
 * - First connection requires manual server key verification
 * - Client key whitelisting restricts server access
 * - Mutual authentication (both parties prove identity)
 *
 * **Timing Attacks**:
 * - All crypto operations use constant-time implementations
 * - MAC verification is constant-time (prevents padding oracle)
 * - Key comparison uses sodium_memcmp (constant-time)
 * - No data-dependent branches in crypto code
 *
 * **Replay Protection**:
 * - Nonce sequence numbers prevent replay attacks
 * - Out-of-order packets are rejected
 * - Duplicate nonces are rejected
 * - Timestamp checking in handshake (prevents delayed replay)
 *
 * @section crypto_performance Performance
 *
 * Benchmarks on Intel i7-10700K @ 3.8 GHz:
 * - X25519 key generation: ~30,000 ops/sec
 * - X25519 shared secret: ~30,000 ops/sec
 * - Ed25519 signing: ~25,000 ops/sec
 * - Ed25519 verification: ~70,000 ops/sec
 * - XSalsa20-Poly1305 encryption: ~1.2 GB/sec
 * - XSalsa20-Poly1305 decryption: ~1.2 GB/sec
 * - Handshake latency: ~2-5 ms (includes network RTT)
 *
 * For 1920x1080 RGB frames (~6 MB) at 60 FPS:
 * - Encryption overhead: ~5% CPU
 * - Negligible impact on frame rate
 *
 * @see crypto/crypto.h
 * @see crypto/handshake.h
 * @see crypto/keys/keys.h
 * @see crypto/ssh_agent.h
 * @see crypto/known_hosts.h
 */
