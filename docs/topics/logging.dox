/**
 * @page topic_logging Logging README
 * @ingroup logging
 *
 * @section logging_overview Overview
 *
 * Welcome to the logging system! If you've ever tried to debug a complex program without good
 * logging, you know the pain. The logging system is your debugging best friend—it helps you
 * understand what's happening in your application, track down bugs, and monitor behavior in
 * production.
 *
 * Think of logging as your application's diary. It writes down everything that happens: when
 * clients connect, when errors occur, when packets are processed. You can configure how chatty
 * it should be (from super verbose DEBUG mode to quiet ERROR-only mode), and you can send the
 * output to the console, to a file, or both!
 *
 * **Implementation**: lib/logging.h
 *
 * What makes this logging system helpful?
 * ----------------------------------------
 * - **Six log levels**: DEV, DEBUG, INFO, WARN, ERROR, FATAL (choose your verbosity)
 * - **Rate limiting**: Prevents log spam in tight loops (your disk will thank you)
 * - **Flexible output**: Console, file, or both simultaneously
 * - **Thread-safe**: Multiple threads can log without stepping on each other
 * - **Context tracking**: Automatic timestamps and source location (file:line)
 * - **Pretty colors**: Colored console output so errors jump out at you
 * - **Runtime configuration**: Change log level on the fly via environment variable
 *
 * @section logging_levels Log Levels
 *
 * The logging system has six levels, from most verbose to least:
 *
 * **DEV (0)** - The super chatty one:
 * - Use this for development-only messages that are too verbose for normal debugging
 * - Useful for tracing code paths during active development
 * - Usually disabled even in debug builds unless you need extreme detail
 *
 * **DEBUG (1)** - The chatty one:
 * - Use this when you need detailed diagnostic information
 * - Only available in debug builds (stripped out in release for performance)
 * - Perfect for understanding exactly what's happening step by step
 *
 * **INFO (2)** - The reporter:
 * - General informational messages about normal operations
 * - "Client connected", "Frame processed", that sort of thing
 * - What you'd want to see during normal operation
 *
 * **WARN (3)** - The concerned citizen:
 * - Something's not quite right, but we can keep going
 * - "Buffer is getting full", "Retrying connection"
 * - Pay attention, but don't panic
 *
 * **ERROR (4)** - Houston, we have a problem:
 * - Operation failures that are recoverable
 * - "Failed to send packet", "Client disconnected unexpectedly"
 * - Things went wrong, but we're handling it
 *
 * **FATAL (5)** - The showstopper:
 * - Unrecoverable errors that mean we can't continue
 * - "Cannot initialize crypto", "Out of memory"
 * - Time to gracefully shut down
 *
 * @section logging_usage Basic Usage
 *
 * @subsection logging_basic Basic Logging
 *
 * **Log Messages**:
 * @code{.c}
 * log_debug("Processing frame %d", frame_number);
 * log_info("Client connected: %s:%d", ip, port);
 * log_warn("Buffer nearly full: %zu/%zu", used, capacity);
 * log_error("Failed to send packet: %s", error_msg);
 * log_fatal("Cannot initialize crypto: %s", reason);
 * @endcode
 *
 * **Format Specifiers**:
 * @code{.c}
 * log_info("Integer: %d", 42);
 * log_info("String: %s", "hello");
 * log_info("Pointer: %p", ptr);
 * log_info("Size: %zu bytes", size);
 * log_info("Hex: 0x%08x", value);
 * @endcode
 *
 * @subsection logging_rate_limiting Rate-Limited Logging
 *
 * **Rate Limiting** (prevents log spam in tight loops):
 * @code{.c}
 * // Log at most once per second (1,000,000 microseconds)
 * for (int i = 0; i < 1000000; i++) {
 *     log_debug_every(1000000, "Processing item %d", i);
 * }
 *
 * // Log at most once per 5 seconds
 * while (video_running) {
 *     log_info_every(5000000, "Video frames processed: %d", frame_count);
 *     process_frame();
 * }
 * @endcode
 *
 * **Available Rate-Limited Macros**:
 * - log_debug_every(usec, ...)
 * - log_info_every(usec, ...)
 * - log_warn_every(usec, ...)
 * - log_error_every(usec, ...)
 *
 * @section logging_configuration Configuration
 *
 * @subsection logging_level Setting Log Level
 *
 * **Runtime Configuration**:
 * @code{.c}
 * // Set log level to DEBUG
 * set_log_level(LOG_LEVEL_DEBUG);
 *
 * // Set log level to INFO (hide debug messages)
 * set_log_level(LOG_LEVEL_INFO);
 *
 * // Set log level to ERROR (only errors and fatal)
 * set_log_level(LOG_LEVEL_ERROR);
 * @endcode
 *
 * **Environment Variable**:
 * @code{.sh}
 * # Set log level via environment
 * export LOG_LEVEL=0  # DEV
 * export LOG_LEVEL=1  # DEBUG
 * export LOG_LEVEL=2  # INFO
 * export LOG_LEVEL=3  # WARN
 * export LOG_LEVEL=4  # ERROR
 * export LOG_LEVEL=5  # FATAL
 *
 * # Run with debug logging
 * LOG_LEVEL=1 ./bin/ascii-chat server
 * @endcode
 *
 * @subsection logging_file_output File Output
 *
 * **Configure File Logging**:
 * @code{.c}
 * // Enable logging to file
 * set_log_file("/tmp/ascii-chat-server.log");
 *
 * // Logs now go to both console and file
 * log_info("This appears in both console and file");
 *
 * // Close log file
 * close_log_file();
 * @endcode
 *
 * **Command-line Option**:
 * @code{.sh}
 * # Log to file via command line
 * ./bin/ascii-chat server --log-file=/tmp/server.log
 * ./bin/ascii-chat client --log-file=/tmp/client.log
 * @endcode
 *
 * @section logging_format Output Format
 *
 * Log messages have a consistent format that makes them easy to read and
 * understand. Every message includes a timestamp, level, source location,
 * and the actual message text. Let's look at the format:
 *
 * What does a log message look like?
 * ----------------------------------
 * **Log Message Format**:
 * ```
 * [TIMESTAMP] LEVEL [file:line] message
 * ```
 *
 * The format is simple and consistent—timestamp first (so you can see when
 * things happened), level next (so you know how important it is), source
 * location (so you know where in the code it came from), and the message
 * itself.
 *
 * **Example Output**:
 * ```
 * [2025-01-15 14:23:45] DEBUG [server.c:234] Starting video capture thread
 * [2025-01-15 14:23:45] INFO  [network.c:456] Client connected: 192.168.1.100:54321
 * [2025-01-15 14:23:46] WARN  [audio.c:123] Audio buffer 80% full
 * [2025-01-15 14:23:47] ERROR [crypto.c:789] Handshake failed: invalid signature
 * ```
 *
 * Notice how you can see exactly when things happened, what level they are,
 * where in the code they came from, and what the message is. This makes
 * debugging much easier!
 *
 * What about colors?
 * ------------------
 * **Console Colors** (ANSI terminals):
 * - **DEV**: Dim Gray (even more subtle, for development tracing)
 * - **DEBUG**: Gray (subtle, so it doesn't distract from important messages)
 * - **INFO**: White (default color, for normal messages)
 * - **WARN**: Yellow (gets your attention, but not too alarming)
 * - **ERROR**: Red (you should pay attention to this!)
 * - **FATAL**: Bold Red (this is serious!)
 *
 * Colors make it easy to scan logs—errors jump out in red, warnings in yellow.
 * If you're in a terminal that supports colors, this makes debugging much
 * easier.
 *
 * @section logging_threading Thread Safety
 *
 * **Mutex Protection**:
 * - All logging operations are protected by a global mutex
 * - Safe for concurrent logging from multiple threads
 * - No output interleaving
 *
 * **Thread Identification**:
 * - Thread ID automatically captured (debug builds)
 * - Helps trace multi-threaded execution
 *
 * **Example Multi-threaded Logging**:
 * @code{.c}
 * void* worker_thread(void *arg) {
 *     log_info("Worker thread started");  // Thread-safe
 *
 *     for (int i = 0; i < 1000; i++) {
 *         // Rate-limited, thread-safe
 *         log_debug_every(1000000, "Processing item %d", i);
 *     }
 *
 *     log_info("Worker thread finished");
 *     return NULL;
 * }
 * @endcode
 *
 * @section logging_performance Performance Considerations
 *
 * Logging performance is important—you don't want logging to slow down your
 * application. We've designed the system to be efficient, but there are some
 * things to keep in mind:
 *
 * How do we keep logging fast?
 * ---------------------------
 * **Rate Limiting**:
 * - **Use log_*_every() in high-frequency code paths**: If you're logging in a
 *   tight loop, use rate limiting so you don't flood the logs
 * - **Prevents log spam and performance degradation**: Without rate limiting,
 *   logging can slow down your application significantly
 * - **Minimal overhead when rate limit is active**: Once the rate limit is
 *   active, logging is essentially free (we just check if enough time has
 *   passed, then skip logging)
 *
 * Rate limiting is your friend in tight loops—you can log every iteration
 * without actually logging every iteration!
 *
 * How about file I/O?
 * -------------------
 * **File I/O**:
 * - **File logging adds I/O overhead**: Writing to a file is slower than
 *   writing to console, but it's still pretty fast for most use cases
 * - **Consider async file writing for high-throughput**: If you're logging a
 *   lot (thousands of messages per second), you might want async file writing
 * - **Use buffered output for better performance**: We use buffered I/O, so
 *   multiple log messages can be written in one operation
 *
 * File logging is pretty fast—we use buffered I/O, so most of the time you
 * won't notice the overhead. If you're logging hundreds of messages per second,
 * you might want to consider rate limiting or async logging.
 *
 * What about string formatting?
 * -----------------------------
 * **String Formatting**:
 * - **Avoid expensive formatting in hot paths**: String formatting (like
 *   `sprintf()`) can be slow if you're doing it thousands of times per second
 * - **Use rate limiting for frequent messages**: If you're logging frequently,
 *   rate limiting reduces the number of format operations
 * - **Consider conditional compilation for debug logs**: Debug logs can be
 *   compiled out entirely in release builds, so they have zero overhead
 *
 * String formatting is usually pretty fast, but if you're doing it millions
 * of times per second, it can add up. Use rate limiting for frequent messages,
 * and remember that debug logs are compiled out in release builds!
 *
 * @section logging_best_practices Best Practices
 *
 * **DO**:
 * - Use appropriate log levels
 * - Use rate limiting in tight loops
 * - Include relevant context (IDs, values)
 * - Use structured messages
 * - Log errors with error codes
 *
 * **DON'T**:
 * - Don't use printf() directly (use log_*() instead)
 * - Don't log in tight loops without rate limiting
 * - Don't log sensitive data (passwords, keys)
 * - Don't use DEBUG level for production
 * - Don't log every iteration of a loop
 *
 * **Examples**:
 * @code{.c}
 * // ✅ GOOD - Rate limited
 * for (int i = 0; i < 1000000; i++) {
 *     log_debug_every(1000000, "Processed %d items", i);
 * }
 *
 * // ❌ BAD - Logs 1 million times!
 * for (int i = 0; i < 1000000; i++) {
 *     log_debug("Processing item %d", i);
 * }
 *
 * // ✅ GOOD - Contextual error message
 * log_error("Failed to send packet to client %u: %s", client_id, error_msg);
 *
 * // ❌ BAD - Generic message
 * log_error("Send failed");
 * @endcode
 *
 * @section logging_integration Integration with Error System
 *
 * **Automatic Error Logging**:
 * - SET_ERRNO() macros automatically log errors
 * - Error context included in log messages
 * - File/line/function captured automatically
 *
 * **Example**:
 * @code{.c}
 * if (socket_fd < 0) {
 *     // Automatically logs: "ERROR: Failed to create socket"
 *     return SET_ERRNO(ERROR_NETWORK_SOCKET, "Failed to create socket");
 * }
 * @endcode
 *
 * @see logging.h
 * @see asciichat_errno.h
 * @see common.h
 */
