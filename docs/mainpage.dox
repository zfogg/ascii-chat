/**
 * @mainpage ascii-chat API Documentation
 *
 * @section intro_sec Introduction
 *
 * ascii-chat is a real-time terminal-based video chat application that converts
 * video streams to ASCII art for display in terminals. It supports multiple clients,
 * audio streaming, and end-to-end encryption.
 *
 * This documentation provides comprehensive API reference and architectural guidance
 * for developers working with ascii-chat. Whether you're integrating ascii-chat into
 * your application, extending its functionality, or contributing to the project, this
 * documentation will help you understand the codebase structure and implementation
 * details.
 *
 * @note **Getting Started?** We recommend starting with the @ref topic_build "Build System" topic
 *       to understand how to compile ascii-chat on Windows, Linux, and macOS, configure
 *       the build system, and set up your development environment.
 *
 * @warning **Important:** When exploring this documentation, we strongly urge you to **search for "README"** and
 *          **"MODULE"** pages early on. These pages provide comprehensive overviews and are excellent entry points
 *          for understanding major subsystems. Use the search functionality (Ctrl+F / Cmd+F or the search bar) to
 *          find these pages quickly.
 *
 * @section exploring_docs Exploring the Documentation
 *
 * This documentation is organized into several sections accessible from the navigation
 * menu on the left:
 *
 * @subsection mainpage_this_page Main Page (This Page)
 *
 * You're currently viewing the main landing page. This provides:
 * - Project overview and introduction
 * - Quick navigation guide
 * - Links to major modules and subsystems
 * - Getting started examples
 *
 * @subsection topics_page Topics (Detailed Guides)
 *
 * For in-depth architectural documentation and implementation details, visit the
 * **@ref topic_categories "Topic Categories"** page. This section provides comprehensive
 * guides organized by subsystem:
 *
 * - **@ref topic_build "Build System"**: CMake configuration, cross-platform compilation, build types,
 *   platform-specific gotchas, static builds, and build optimizations (start here!)
 * - **Core Modules**: Cryptography, handshake protocol, key management
 * - **Data Structures**: Buffer pools, ring buffers, packet queues, hash tables
 * - **Media Processing**: Audio system, image-to-ASCII conversion, palette management
 * - **Platform Support**: Cross-platform abstractions, OS-specific functionality
 * - **Network Layer**: Socket operations, packet protocol, audio/video networking
 * - **Core Libraries**: Common definitions, configuration
 * - **Debugging**: Error handling, lock debugging, memory leak detection
 *
 * @subsubsection how_to_use_topics How to Use Topics
 *
 * Each topic page provides:
 * - **Overview**: High-level description of the subsystem
 * - **Architecture**: Design decisions and structural details
 * - **API Reference**: Function signatures and usage patterns
 * - **Examples**: Code samples showing how to use the APIs
 * - **Integration**: How the module fits into the larger system
 * - **Performance**: Benchmarks and optimization notes
 * - **Best Practices**: Recommended usage patterns and common pitfalls
 *
 * @subsection modules_page Modules (Code Organization)
 *
 * The **Modules** section groups related code elements together:
 * - Functions, structures, and constants are organized by functionality
 * - Each module represents a logical subsystem (e.g., Audio System, Crypto Module)
 * - Module pages automatically include all documented code elements with `@ingroup`
 * - Use this for quick API reference and browsing related functionality
 *
 * @subsection pages_page Related Pages
 *
 * The **Related Pages** section contains:
 * - **Topics**: Topic Categories and individual topic guides
 * - Topic pages merge module documentation with detailed explanations
 * - Links from topic pages to related code elements
 *
 * @subsection files_page Files (Source Code)
 *
 * The **Files** section lists all source files in the project:
 * - Header files (`.h`) with file-level documentation
 * - Implementation files (`.c`) for implementation details
 * - Organized by directory structure
 * - Each file's documentation describes its purpose and key features
 *
 * @subsection class_page Data Structures
 *
 * The **Data Structures** section shows all `struct` and `typedef` definitions:
 * - Structures organized by module
 * - Member documentation with types and descriptions
 * - Links to related functions and usage examples
 *
 * @section navigation_tips Navigation Tips
 *
 * @subsection quick_start Quick Start
 *
 * **New to ascii-chat?** Start here:
 *
 * 1. **Set up your build environment**: Read @ref topic_build "Build System" to learn how to
 *    compile ascii-chat on your platform (Windows, Linux, or macOS) and understand the
 *    CMake configuration, build types, and platform-specific considerations
 * 2. Read this main page to understand the project overview
 * 3. Visit @ref topic_categories "Topic Categories" to browse detailed guides
 * 4. Check out @ref getting_started "Getting Started" section below for code examples
 * 5. Explore the **Modules** section for API reference organized by functionality
 *
 * @subsection finding_code Finding Code Elements
 *
 * **Looking for a specific function or structure?**
 *
 * - **Use the search bar** at the top of the page (Ctrl+F / Cmd+F in browser)
 * - **Browse Modules** to find related code grouped together
 * - **Check Files** to see all functions in a particular header
 * - **Review Data Structures** to understand type definitions
 *
 * @subsection understanding_system Understanding the System
 *
 * **Want to understand how things work together?**
 *
 * - Read @ref topic_categories "Topic Pages" for architectural overviews and design explanations
 * - Follow cross-references in documentation to navigate between related concepts
 *   (like @ref topic_build "Build System" or @ref topic_crypto "Cryptography")
 * - Review "See also" references at the bottom of documentation blocks
 * - Check Integration sections in topic pages for how modules interact
 *
 * @subsection contribution_guide Contributing to the Project
 *
 * **Planning to contribute code?**
 *
 * - **Set up your build environment**: Read @ref topic_build "Build System" to configure your
 *   development environment and understand build types, CMake presets, and testing setup
 * - **Read Topic Pages** to understand the architecture before making changes
 * - **Review Best Practices** sections for coding standards and patterns
 * - **Check** @note \@note tags that look like this and @warning \@warning tags that look like this in documentation for important details
 * - **Follow the existing documentation style** when adding new code and format with clang-format
 *
 * @section library_structure Library Structure
 *
 * The library is organized into several major modules:
 *
 * @subsection core_module Core Library
 * - @ref common "Common Definitions" - Error codes, macros, core types
 * - @ref options "Options module" - Command-line options
 * - @ref config "Config module" - File-based configuration
 * - @ref logging "Logging Module" - Logging API and utilities
 *
 * @subsection platform_module Platform Abstractions
 * - @ref platform "Platform Layer" - Cross-platform abstractions for threads, mutexes, sockets, system calls
 * - @ref os "OS Abstractions" - Operating system specific functionality (webcam, etc.)
 *
 * @subsection core_libs_module Core Libraries
 * - @ref buffer_pool "Buffer Pool" - Memory management with pre-allocated buffers
 * - @ref ringbuffer "Ring Buffer" - Circular buffer implementation
 * - @ref packet_queue "Packet Queue" - Queue management for network packets
 *
 * @subsection network_module Network Layer
 * - @ref network "Network Module" - Socket operations, timeouts, connections
 * - @ref packet "Packet Types" - Network packet structures and definitions
 * - @ref av "Audio/Video Networking" - Network APIs for audio/video streaming
 *
 * @subsection crypto_module Cryptography
 * - @ref topic_crypto "Crypto Core" - Core cryptographic operations
 * - @ref handshake "Handshake Protocol" - Cryptographic handshake implementation
 * - @ref keys "Key Management" - SSH key, GPG key, and key validation APIs
 *
 * @subsection media_module Media Processing
 * - @ref audio "Audio System" - Audio capture and playback
 * - @ref palette "Palette Management" - ASCII palette configuration and UTF-8 support
 * - @ref image2ascii "Image to ASCII" - Image conversion and ASCII rendering
 * - @ref video_frame "Video Frames" - Video frame buffer management
 *
 * @subsection util_module Utilities
 * - @ref util "Utilities" - String manipulation, path handling, IP parsing, math utilities, UTF-8 support
 *
 * @section getting_started Getting Started
 *
 * @note Before diving into the code, make sure you've read the @ref topic_build "Build System" topic
 *       to understand how to compile and configure ascii-chat for your platform.
 *
 * This section provides a quick overview of how to use the ascii-chat library.
 * For detailed documentation on each component, see the @ref topic_categories "Topic Categories" page.
 *
 * @subsection typical_workflow Typical Workflow
 *
 * The typical workflow for using the ascii-chat library:
 *
 * 1. Initialize the logging system with log_init()
 * 2. Initialize common subsystems with asciichat_common_init()
 * 3. Initialize platform-specific components (audio, video, network)
 * 4. Set up cryptographic context and perform handshake
 * 5. Start audio/video capture and network streaming
 * 6. Handle incoming packets and render to terminal
 *
 * @subsection example_client Client Workflow: Connect, Handshake, Send Video, Display ASCII
 *
 * Complete client workflow from connection to displaying ASCII frames:
 *
 * @code{.c}
 * // STEP 1: Connect to server and perform crypto handshake
 * // From src/client/main.c and src/client/crypto.c
 *
 * // Connect to server
 * socket_t sockfd = server_connection_connect("127.0.0.1", 27224);
 * if (sockfd == INVALID_SOCKET_VALUE) {
 *     log_error("Failed to connect to server");
 *     return ERROR_NETWORK_CONNECT;
 * }
 *
 * // Perform cryptographic handshake with server
 * // This establishes encrypted session using X25519 key exchange
 * asciichat_error_t handshake_result = crypto_client_perform_handshake();
 * if (handshake_result != ASCIICHAT_OK) {
 *     log_error("Crypto handshake failed");
 *     return handshake_result;
 * }
 * log_info("Encrypted session established with server");
 *
 * // Send client capabilities to server (terminal size, color support, etc.)
 * client_capabilities_packet_t caps = {
 *     .terminal_width = htons(80),
 *     .terminal_height = htons(24),
 *     .supports_color = 1,
 *     .color_mode = COLOR_MODE_TRUECOLOR,
 *     .render_mode = RENDER_MODE_HALF_BLOCK
 * };
 * threaded_send_packet(PACKET_TYPE_CLIENT_CAPABILITIES, &caps, sizeof(caps), 0);
 *
 * // STEP 2: Capture webcam frame and send to server
 * // From src/client/capture.c
 *
 * // Capture RGB frame from webcam (640x480 in this example)
 * rgb_t *webcam_pixels = NULL;
 * int width = 640, height = 480;
 * if (webcam_capture_frame(&webcam_pixels, &width, &height) != 0) {
 *     log_error("Failed to capture webcam frame");
 *     return ERROR_WEBCAM;
 * }
 *
 * // Package frame: [width:4][height:4][rgb_data:w*h*3]
 * size_t frame_size = sizeof(uint32_t) * 2 + (size_t)width * (size_t)height * sizeof(rgb_t);
 * uint8_t *frame_data = SAFE_MALLOC(frame_size, uint8_t *);
 *
 * // Write dimensions in network byte order
 * *(uint32_t *)frame_data = htonl(width);
 * *(uint32_t *)(frame_data + sizeof(uint32_t)) = htonl(height);
 *
 * // Copy pixel data
 * memcpy(frame_data + sizeof(uint32_t) * 2, webcam_pixels,
 *        (size_t)width * (size_t)height * sizeof(rgb_t));
 *
 * // Send image frame to server (automatically encrypted after handshake)
 * threaded_send_packet(PACKET_TYPE_IMAGE_FRAME, frame_data, frame_size, 0);
 *
 * SAFE_FREE(frame_data);
 * log_debug("Sent %dx%d webcam frame to server", width, height);
 *
 * // STEP 3: Receive ASCII frame from server and display
 * // From src/client/protocol.c
 *
 * // Receive packet (automatically decrypted)
 * bool crypto_ready = crypto_client_is_ready();
 * const crypto_context_t *crypto_ctx = crypto_client_get_context();
 * packet_envelope_t envelope;
 * packet_recv_result_t result = receive_packet_secure(sockfd, (void *)crypto_ctx,
 *                                                     crypto_ready, &envelope);
 *
 * if (result == PACKET_RECV_OK && envelope.type == PACKET_TYPE_ASCII_FRAME) {
 *     // Parse ASCII frame header
 *     ascii_frame_packet_t *header = (ascii_frame_packet_t *)envelope.data;
 *     header->width = ntohl(header->width);
 *     header->height = ntohl(header->height);
 *     header->original_size = ntohl(header->original_size);
 *     header->checksum = ntohl(header->checksum);
 *
 *     // Extract ASCII art string
 *     const char *frame_data_ptr = (const char *)envelope.data + sizeof(ascii_frame_packet_t);
 *     char *ascii_frame = SAFE_MALLOC(header->original_size + 1, char *);
 *     memcpy(ascii_frame, frame_data_ptr, header->original_size);
 *     ascii_frame[header->original_size] = '\0';
 *
 *     // Verify integrity
 *     uint32_t actual_crc = asciichat_crc32(ascii_frame, header->original_size);
 *     if (actual_crc == header->checksum) {
 *         // Display ASCII art in terminal
 *         display_render_frame(ascii_frame, false);
 *         log_debug("Displayed %ux%u ASCII frame", header->width, header->height);
 *     }
 *
 *     SAFE_FREE(ascii_frame);
 *     buffer_pool_free(envelope.allocated_buffer, envelope.allocated_size);
 * }
 * @endcode
 *
 * @subsection example_server Server Workflow: Receive Video, Convert to ASCII, Broadcast
 *
 * Complete server workflow showing client connection, video reception, ASCII conversion, and broadcasting:
 *
 * @code{.c}
 * // STEP 1: Accept client connection and perform crypto handshake
 * // From src/server/main.c and src/server/crypto.c
 *
 * // Accept incoming client connection
 * socket_t client_sockfd = socket_accept(listen_sockfd, NULL, NULL);
 * if (client_sockfd == INVALID_SOCKET_VALUE) {
 *     log_error("Failed to accept client connection");
 *     return ERROR_NETWORK_ACCEPT;
 * }
 *
 * // Assign client ID and create client info structure
 * uint32_t client_id = allocate_client_id();
 * client_info_t *client = create_client_info(client_id, client_sockfd);
 *
 * // Perform server-side crypto handshake
 * asciichat_error_t handshake_result = crypto_server_perform_handshake(client);
 * if (handshake_result != ASCIICHAT_OK) {
 *     log_error("Crypto handshake failed for client %u", client_id);
 *     close_client_connection(client);
 *     return handshake_result;
 * }
 * log_info("Client %u: Encrypted session established", client_id);
 *
 * // STEP 2: Receive video frame from client
 * // From src/server/protocol.c
 *
 * // Receive packet from client (automatically decrypted)
 * bool crypto_ready = crypto_server_client_is_ready(client);
 * const crypto_context_t *crypto_ctx = crypto_server_get_client_context(client);
 * packet_envelope_t envelope;
 * packet_recv_result_t result = receive_packet_secure(client_sockfd, (void *)crypto_ctx,
 *                                                     crypto_ready, &envelope);
 *
 * if (result == PACKET_RECV_OK && envelope.type == PACKET_TYPE_IMAGE_FRAME) {
 *     // Parse image frame: [width:4][height:4][rgb_data:w*h*3]
 *     uint32_t img_width = ntohl(*(uint32_t *)envelope.data);
 *     uint32_t img_height = ntohl(*(uint32_t *)(envelope.data + sizeof(uint32_t)));
 *     rgb_t *pixels = (rgb_t *)(envelope.data + sizeof(uint32_t) * 2);
 *
 *     log_debug("Client %u: Received %ux%u video frame", client_id, img_width, img_height);
 *
 *     // Store frame in client's incoming video buffer
 *     video_frame_store(client->incoming_video_buffer, envelope.data, envelope.len);
 *
 *     // Mark client as sending video
 *     atomic_store(&client->is_sending_video, true);
 *
 *     buffer_pool_free(envelope.allocated_buffer, envelope.allocated_size);
 * }
 *
 * // STEP 3: Convert video to ASCII and broadcast to all clients
 * // From src/server/stream.c and src/server/render.c
 *
 * // For each connected client, generate personalized ASCII frame
 * for (int i = 0; i < MAX_CLIENTS; i++) {
 *     client_info_t *target_client = &g_client_manager.clients[i];
 *     if (!atomic_load(&target_client->active)) {
 *         continue;
 *     }
 *
 *     // Get target client's terminal dimensions
 *     unsigned short term_width = target_client->terminal_caps.width;
 *     unsigned short term_height = target_client->terminal_caps.height;
 *
 *     // Mix video from ALL clients into composite for this target client
 *     size_t ascii_size = 0;
 *     char *ascii_frame = create_mixed_ascii_frame_for_client(
 *         target_client->client_id, term_width, term_height, &ascii_size);
 *
 *     if (!ascii_frame) {
 *         continue; // No video sources available yet
 *     }
 *
 *     // Package ASCII frame with header
 *     ascii_frame_packet_t packet_header = {
 *         .width = htonl(term_width),
 *         .height = htonl(term_height),
 *         .original_size = htonl(ascii_size),
 *         .compressed_size = 0,
 *         .checksum = htonl(asciichat_crc32(ascii_frame, ascii_size)),
 *         .flags = 0
 *     };
 *
 *     // Combine header + ASCII data into single packet
 *     size_t total_size = sizeof(packet_header) + ascii_size;
 *     uint8_t *packet_data = SAFE_MALLOC(total_size, uint8_t *);
 *     memcpy(packet_data, &packet_header, sizeof(packet_header));
 *     memcpy(packet_data + sizeof(packet_header), ascii_frame, ascii_size);
 *
 *     // Send to target client (automatically encrypted)
 *     threaded_send_packet_to_client(target_client, PACKET_TYPE_ASCII_FRAME,
 *                                    packet_data, total_size);
 *
 *     log_debug("Sent %zub ASCII frame to client %u", total_size, target_client->client_id);
 *
 *     SAFE_FREE(ascii_frame);
 *     SAFE_FREE(packet_data);
 * }
 *
 * // STEP 4: Mix and broadcast audio to all clients
 * // From src/server/mixer.c
 *
 * // Mix audio from all clients (excluding target client's own audio)
 * for (int i = 0; i < MAX_CLIENTS; i++) {
 *     client_info_t *target_client = &g_client_manager.clients[i];
 *     if (!atomic_load(&target_client->active)) {
 *         continue;
 *     }
 *
 *     // Get mixed audio for this client (excludes their own audio)
 *     float mixed_audio[AUDIO_SAMPLES_PER_PACKET];
 *     int sample_count = mixer_get_mixed_audio_for_client(target_client->client_id,
 *                                                         mixed_audio, AUDIO_SAMPLES_PER_PACKET);
 *
 *     if (sample_count > 0) {
 *         // Send audio packet to client
 *         size_t audio_size = sample_count * sizeof(float);
 *         queue_audio_for_client(target_client, mixed_audio, audio_size);
 *     }
 * }
 * @endcode
 *
 * @subsection example_notes Important Notes
 *
 * **Encryption**:
 * - All packets are automatically encrypted after the crypto handshake
 * - Use `threaded_send_packet()` or `receive_packet_secure()` for encrypted I/O
 * - Crypto context is per-connection (client or server)
 * - Keys are automatically zeroed on `crypto_destroy()`
 *
 * **Compression**:
 * - Large packets (>100KB) are automatically compressed
 * - Compression is transparent - handled by packet I/O functions
 * - Use `av_send_*()` functions for media packets with compression
 *
 * **Client Capabilities**:
 * - Sent once after crypto handshake
 * - Includes terminal size, color support, palette preferences
 * - Server uses this to format output appropriately
 *
 * **Thread Safety**:
 * - `threaded_send_packet()` is thread-safe for concurrent sending
 * - `receive_packet_secure()` should be called from dedicated receive thread
 * - Crypto context is per-connection (not thread-safe for concurrent access)
 *
 * For more details, see the @ref topic_categories "Topic Categories" page:
 * - @ref topic_build "Build System" for compilation and build configuration
 * - @ref topic_crypto "Cryptography Module" for encryption details
 * - @ref topic_handshake "Handshake Protocol" for authentication
 * - @ref topic_keys "Key Management" for SSH/GPG key handling
 * - @ref topic_av "Audio/Video Networking" for media packet APIs
 * - @ref topic_network "Network I/O" for packet I/O operations
 *
 * @section building Building Documentation
 *
 * To build this documentation, you'll need Doxygen configured. See @ref topic_build "Build System"
 * for information on configuring the project with CMake, including documentation generation.
 *
 * To build this documentation:
 *
 * @code{.bash}
 * cmake --build build --target docs
 * @endcode
 *
 * The documentation will be generated in `build/docs/html/index.html`.
 *
 * To open the documentation in your browser:
 *
 * @code{.bash}
 * cmake --build build --target docs-open
 * @endcode
 *
 * For more information on the build system, including CMake configuration, build types, and
 * platform-specific considerations, see @ref topic_build "Build System".
 *
 * @section modules Modules
 *
 * @note Most module groups are defined in their respective header files.
 *       See @ref build "Build System", @ref testing "Testing", @ref common
 *       "Common Definitions", @ref logging "Logging System", @ref options
 *       "Options", @ref platform "Platform Abstractions", @ref os "OS
 *       Abstractions", @ref buffer_pool "Buffer Pool", @ref ringbuffer "Ring
 *       Buffer", @ref packet_queue "Packet Queue", @ref network "Network I/O",
 *       @ref packet "Packet Types", @ref av "Audio/Video Networking", @ref
 *       crypto "Cryptography", @ref handshake "Handshake Protocol", @ref keys
 *       "Key Management", @ref audio "Audio System", @ref palette "Palette
 *       Management", @ref image2ascii "Image to ASCII", @ref video_frame "Video
 *       Frames", and @ref util "Utilities" for detailed documentation.
 *
 * @section license License
 *
 * See the LICENSE file for license information.
 *
 * @section links Links
 *
 * - Project Homepage: https://github.com/zfogg/ascii-chat
 * - Issues: https://github.com/zfogg/ascii-chat/issues
 * - Releases: https://github.com/zfogg/ascii-chat/releases
 *
 */

